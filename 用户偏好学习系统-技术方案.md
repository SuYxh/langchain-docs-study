# 用户偏好学习系统 - 技术方案

## 一、概述

### 1.1 背景

在 AI 内容生成场景中，用户对生成内容的风格、表达方式有不同的偏好。通过学习用户的历史反馈和行为，可以实现个性化的内容生成，提升用户满意度。

### 1.2 目标

- 记录和存储用户的显式偏好设置
- 从用户反馈中自动学习隐式偏好
- 将学习到的偏好应用于内容生成
- 实现跨会话的长期记忆

### 1.3 适用场景

| 场景 | 描述 |
|-----|------|
| 房产直播话术生成 | 学习用户偏好的主播风格、话术表达 |
| 营销文案生成 | 学习用户偏好的文案调性、长度 |
| 内容创作助手 | 学习用户的写作风格、常用表达 |
| 客服话术生成 | 学习用户偏好的沟通方式 |

---

## 二、系统架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          用户偏好学习系统                                     │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   偏好采集   │ ──▶ │   偏好存储   │ ──▶ │   偏好分析   │ ──▶ │   偏好应用   │
│    层       │     │    层       │     │    层       │     │    层       │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
      │                    │                    │                    │
      ▼                    ▼                    ▼                    ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ • 显式设置   │     │ • 数据库     │     │ • 模式提取   │     │ • Prompt注入 │
│ • 显式反馈   │     │ • 长期记忆   │     │ • 趋势分析   │     │ • 参数调整   │
│ • 隐式行为   │     │ • 会话缓存   │     │ • 聚类学习   │     │ • 内容过滤   │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```

### 2.2 数据流

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            偏好学习闭环                                      │
└─────────────────────────────────────────────────────────────────────────────┘

     ┌──────────┐         ┌──────────┐         ┌──────────┐
     │  内容    │ ──────▶ │  用户    │ ──────▶ │  反馈    │
     │  生成    │         │  使用    │         │  收集    │
     └──────────┘         └──────────┘         └────┬─────┘
          ▲                                         │
          │                                         ▼
     ┌────┴─────┐         ┌──────────┐         ┌──────────┐
     │  偏好    │ ◀────── │  偏好    │ ◀────── │  反馈    │
     │  应用    │         │  更新    │         │  分析    │
     └──────────┘         └──────────┘         └──────────┘
```

---

## 三、偏好数据模型

### 3.1 用户偏好数据结构

```typescript
interface UserPreference {
  userId: string;
  
  // ==================== 显式偏好（用户主动设置）====================
  settings: {
    // 风格偏好
    preferredStyle: 'energetic' | 'professional' | 'storyteller' | 'local_expert';
    
    // 内容偏好
    preferredLength: 'short' | 'medium' | 'long';
    preferredTone: 'rational' | 'emotional' | 'balanced';
    detailLevel: 'brief' | 'detailed';
    
    // 格式偏好
    useEmoji: boolean;
    useBulletPoints: boolean;
  };
  
  // ==================== 学习偏好（系统分析得出）====================
  learned: {
    // 喜欢的表达模式
    likedPhrases: string[];
    likedOpeningStyles: string[];
    likedClosingStyles: string[];
    
    // 不喜欢的表达模式
    dislikedPhrases: string[];
    dislikedPatterns: string[];
    
    // 统计数据
    averageRating: number;
    preferredWordCount: number;
    
    // 置信度（学习样本越多越高）
    confidence: number;
  };
  
  // ==================== 历史记录 ====================
  history: {
    totalGenerations: number;
    totalFeedbacks: number;
    recentGenerations: RecentGeneration[];
  };
  
  // ==================== 元数据 ====================
  createdAt: Date;
  updatedAt: Date;
  lastActiveAt: Date;
}

interface RecentGeneration {
  generationId: string;
  style: string;
  openingType: string;
  rating?: number;
  createdAt: Date;
}
```

### 3.2 反馈数据结构

```typescript
// 显式反馈 - 用户主动评价
interface ExplicitFeedback {
  feedbackId: string;
  userId: string;
  generationId: string;
  
  // 整体评分
  rating: 1 | 2 | 3 | 4 | 5;
  
  // 分段评价（可选）
  sectionRatings?: {
    opening: 'like' | 'dislike' | 'neutral';
    content: 'like' | 'dislike' | 'neutral';
    closing: 'like' | 'dislike' | 'neutral';
  };
  
  // 标签反馈
  tags?: ('太长' | '太短' | '太正式' | '太随意' | '很好' | '有创意')[];
  
  // 文本反馈
  comments?: string;
  
  timestamp: Date;
}

// 隐式反馈 - 从用户行为推断
interface ImplicitFeedback {
  feedbackId: string;
  userId: string;
  generationId: string;
  
  // 使用行为
  wasUsed: boolean;              // 是否实际使用
  wasCopied: boolean;            // 是否复制
  wasShared: boolean;            // 是否分享
  
  // 编辑行为
  editPercentage: number;        // 编辑修改比例（0-1）
  deletedSections: string[];     // 被删除的段落
  modifiedSections: string[];    // 被修改的段落
  addedContent: string[];        // 新增的内容
  
  // 重试行为
  regenerateCount: number;       // 重新生成次数
  
  // 时间行为
  viewDuration: number;          // 查看时长（秒）
  timeToFirstEdit: number;       // 首次编辑时间
  
  timestamp: Date;
}
```

---

## 四、技术实现方案

### 4.1 方案一：LangGraph 长期记忆

使用 LangGraph 的 `MemoryStore` 实现跨会话的偏好存储。

**适用场景**：
- 需要与 LangGraph Agent 深度集成
- 偏好数据需要在对话流程中实时访问
- 需要支持复杂的记忆检索

**实现代码**：

```typescript
import { InMemoryStore, PostgresStore } from "@langchain/langgraph";
import { v4 as uuidv4 } from "uuid";

// 1. 创建长期记忆存储
// 开发环境使用 InMemoryStore，生产环境使用 PostgresStore
const memoryStore = process.env.NODE_ENV === 'production'
  ? new PostgresStore({ connectionString: process.env.DATABASE_URL })
  : new InMemoryStore();

// 2. 定义命名空间
const NAMESPACES = {
  SETTINGS: ["user", "settings"],           // 用户设置
  LEARNED: ["user", "learned"],             // 学习偏好
  FEEDBACK: ["user", "feedback"],           // 反馈记录
  HISTORY: ["user", "history"],             // 生成历史
};

// 3. 偏好存储服务
class PreferenceMemoryService {
  
  // 保存用户设置
  async saveSettings(userId: string, settings: UserSettings): Promise<void> {
    await memoryStore.put(
      [...NAMESPACES.SETTINGS, userId],
      "current",
      {
        value: settings,
        updatedAt: new Date().toISOString(),
      }
    );
  }
  
  // 获取用户设置
  async getSettings(userId: string): Promise<UserSettings | null> {
    const result = await memoryStore.get(
      [...NAMESPACES.SETTINGS, userId],
      "current"
    );
    return result?.value || null;
  }
  
  // 保存学习到的偏好
  async saveLearnedPreference(userId: string, learned: LearnedPreference): Promise<void> {
    await memoryStore.put(
      [...NAMESPACES.LEARNED, userId],
      "current",
      {
        value: learned,
        updatedAt: new Date().toISOString(),
        confidence: learned.confidence,
      }
    );
  }
  
  // 获取学习到的偏好
  async getLearnedPreference(userId: string): Promise<LearnedPreference | null> {
    const result = await memoryStore.get(
      [...NAMESPACES.LEARNED, userId],
      "current"
    );
    return result?.value || null;
  }
  
  // 记录反馈
  async recordFeedback(userId: string, feedback: ExplicitFeedback | ImplicitFeedback): Promise<void> {
    const feedbackId = uuidv4();
    await memoryStore.put(
      [...NAMESPACES.FEEDBACK, userId],
      feedbackId,
      {
        value: feedback,
        createdAt: new Date().toISOString(),
      }
    );
  }
  
  // 获取最近的反馈（用于分析）
  async getRecentFeedbacks(userId: string, limit: number = 50): Promise<Feedback[]> {
    const results = await memoryStore.search(
      [...NAMESPACES.FEEDBACK, userId],
      { limit }
    );
    return results
      .map(r => r.value)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }
  
  // 获取完整的用户偏好（合并设置 + 学习）
  async getFullPreference(userId: string): Promise<UserPreference> {
    const [settings, learned] = await Promise.all([
      this.getSettings(userId),
      this.getLearnedPreference(userId),
    ]);
    
    return {
      userId,
      settings: settings || DEFAULT_SETTINGS,
      learned: learned || DEFAULT_LEARNED,
      history: { totalGenerations: 0, totalFeedbacks: 0, recentGenerations: [] },
      createdAt: new Date(),
      updatedAt: new Date(),
      lastActiveAt: new Date(),
    };
  }
}

// 4. 在 LangGraph 中使用
const preferenceService = new PreferenceMemoryService();

const workflow = new StateGraph(GenerationState)
  .addNode("loadPreference", async (state, config) => {
    const userId = config.configurable?.userId;
    if (!userId) return state;
    
    const preference = await preferenceService.getFullPreference(userId);
    return { ...state, userPreference: preference };
  })
  .addNode("generate", async (state) => {
    // 使用偏好生成内容
    const content = await generateWithPreference(state.input, state.userPreference);
    return { ...state, generatedContent: content };
  })
  .addNode("recordUsage", async (state, config) => {
    const userId = config.configurable?.userId;
    if (userId && state.generatedContent) {
      // 记录生成历史
      await preferenceService.recordGeneration(userId, {
        generationId: state.generationId,
        style: state.usedStyle,
        openingType: state.usedOpeningType,
        createdAt: new Date(),
      });
    }
    return state;
  })
  .addEdge("__start__", "loadPreference")
  .addEdge("loadPreference", "generate")
  .addEdge("generate", "recordUsage")
  .addEdge("recordUsage", "__end__");
```

---

### 4.2 方案二：数据库 + 缓存

使用关系型数据库存储偏好，配合 Redis 缓存提升读取性能。

**适用场景**：
- 需要复杂的查询和统计
- 偏好数据需要与其他业务数据关联
- 需要数据持久化和备份

**数据库 Schema**：

```sql
-- 用户偏好表
CREATE TABLE user_preferences (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(64) UNIQUE NOT NULL,
    
    -- 显式设置（JSON）
    settings JSONB NOT NULL DEFAULT '{}',
    
    -- 学习偏好（JSON）
    learned JSONB NOT NULL DEFAULT '{}',
    
    -- 统计数据
    total_generations INT DEFAULT 0,
    total_feedbacks INT DEFAULT 0,
    average_rating DECIMAL(3,2),
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_active_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 反馈记录表
CREATE TABLE feedbacks (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(64) NOT NULL,
    generation_id VARCHAR(64) NOT NULL,
    
    -- 反馈类型
    feedback_type VARCHAR(20) NOT NULL, -- 'explicit' or 'implicit'
    
    -- 显式反馈字段
    rating INT,
    section_ratings JSONB,
    tags TEXT[],
    comments TEXT,
    
    -- 隐式反馈字段
    was_used BOOLEAN,
    edit_percentage DECIMAL(3,2),
    deleted_sections TEXT[],
    regenerate_count INT,
    view_duration INT,
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES user_preferences(user_id)
);

-- 创建索引
CREATE INDEX idx_feedbacks_user_id ON feedbacks(user_id);
CREATE INDEX idx_feedbacks_created_at ON feedbacks(created_at DESC);
CREATE INDEX idx_feedbacks_rating ON feedbacks(rating) WHERE rating IS NOT NULL;
```

**服务实现**：

```typescript
import { Pool } from 'pg';
import Redis from 'ioredis';

class PreferenceDatabaseService {
  private db: Pool;
  private redis: Redis;
  private CACHE_TTL = 3600; // 1小时缓存
  
  constructor() {
    this.db = new Pool({ connectionString: process.env.DATABASE_URL });
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  // 获取用户偏好（带缓存）
  async getPreference(userId: string): Promise<UserPreference | null> {
    // 1. 先查缓存
    const cacheKey = `pref:${userId}`;
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // 2. 查数据库
    const result = await this.db.query(
      'SELECT * FROM user_preferences WHERE user_id = $1',
      [userId]
    );
    
    if (result.rows.length === 0) {
      return null;
    }
    
    const preference = this.rowToPreference(result.rows[0]);
    
    // 3. 写入缓存
    await this.redis.setex(cacheKey, this.CACHE_TTL, JSON.stringify(preference));
    
    return preference;
  }
  
  // 更新用户设置
  async updateSettings(userId: string, settings: UserSettings): Promise<void> {
    await this.db.query(`
      INSERT INTO user_preferences (user_id, settings)
      VALUES ($1, $2)
      ON CONFLICT (user_id) 
      DO UPDATE SET settings = $2, updated_at = CURRENT_TIMESTAMP
    `, [userId, JSON.stringify(settings)]);
    
    // 清除缓存
    await this.redis.del(`pref:${userId}`);
  }
  
  // 记录反馈
  async recordFeedback(userId: string, feedback: Feedback): Promise<void> {
    const isExplicit = 'rating' in feedback;
    
    await this.db.query(`
      INSERT INTO feedbacks (
        user_id, generation_id, feedback_type,
        rating, section_ratings, tags, comments,
        was_used, edit_percentage, deleted_sections, regenerate_count, view_duration
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    `, [
      userId,
      feedback.generationId,
      isExplicit ? 'explicit' : 'implicit',
      isExplicit ? (feedback as ExplicitFeedback).rating : null,
      isExplicit ? JSON.stringify((feedback as ExplicitFeedback).sectionRatings) : null,
      isExplicit ? (feedback as ExplicitFeedback).tags : null,
      isExplicit ? (feedback as ExplicitFeedback).comments : null,
      !isExplicit ? (feedback as ImplicitFeedback).wasUsed : null,
      !isExplicit ? (feedback as ImplicitFeedback).editPercentage : null,
      !isExplicit ? (feedback as ImplicitFeedback).deletedSections : null,
      !isExplicit ? (feedback as ImplicitFeedback).regenerateCount : null,
      !isExplicit ? (feedback as ImplicitFeedback).viewDuration : null,
    ]);
    
    // 更新统计
    await this.updateStatistics(userId);
    
    // 触发偏好学习（可以异步）
    this.triggerPreferenceLearning(userId);
  }
  
  // 更新统计数据
  private async updateStatistics(userId: string): Promise<void> {
    await this.db.query(`
      UPDATE user_preferences SET
        total_feedbacks = (SELECT COUNT(*) FROM feedbacks WHERE user_id = $1),
        average_rating = (SELECT AVG(rating) FROM feedbacks WHERE user_id = $1 AND rating IS NOT NULL),
        updated_at = CURRENT_TIMESTAMP
      WHERE user_id = $1
    `, [userId]);
    
    await this.redis.del(`pref:${userId}`);
  }
  
  // 触发偏好学习
  private async triggerPreferenceLearning(userId: string): Promise<void> {
    // 可以发送到消息队列异步处理
    // await this.queue.add('learn-preference', { userId });
    
    // 或者直接处理（如果数据量不大）
    await this.learnPreference(userId);
  }
  
  // 学习用户偏好
  async learnPreference(userId: string): Promise<void> {
    // 获取最近的反馈
    const feedbacks = await this.db.query(`
      SELECT * FROM feedbacks 
      WHERE user_id = $1 
      ORDER BY created_at DESC 
      LIMIT 100
    `, [userId]);
    
    if (feedbacks.rows.length < 5) {
      // 样本太少，不进行学习
      return;
    }
    
    // 分析反馈，提取偏好
    const learned = this.analyzeAndLearn(feedbacks.rows);
    
    // 更新学习偏好
    await this.db.query(`
      UPDATE user_preferences 
      SET learned = $2, updated_at = CURRENT_TIMESTAMP
      WHERE user_id = $1
    `, [userId, JSON.stringify(learned)]);
    
    await this.redis.del(`pref:${userId}`);
  }
  
  // 分析反馈，提取偏好模式
  private analyzeAndLearn(feedbacks: FeedbackRow[]): LearnedPreference {
    const explicitFeedbacks = feedbacks.filter(f => f.feedback_type === 'explicit');
    const implicitFeedbacks = feedbacks.filter(f => f.feedback_type === 'implicit');
    
    // 从高评分反馈中提取喜欢的模式
    const highRated = explicitFeedbacks.filter(f => f.rating >= 4);
    const lowRated = explicitFeedbacks.filter(f => f.rating <= 2);
    
    // 从低编辑率反馈中学习
    const lowEdit = implicitFeedbacks.filter(f => f.edit_percentage < 0.2);
    const highEdit = implicitFeedbacks.filter(f => f.edit_percentage > 0.5);
    
    // 分析被删除的内容（用户不喜欢）
    const dislikedPhrases = this.extractPhrases(
      highEdit.flatMap(f => f.deleted_sections || [])
    );
    
    // 计算置信度
    const confidence = Math.min(1, feedbacks.length / 50);
    
    return {
      likedPhrases: [], // 需要结合生成内容分析
      likedOpeningStyles: this.extractOpeningStyles(highRated),
      likedClosingStyles: [],
      dislikedPhrases,
      dislikedPatterns: [],
      averageRating: this.calculateAverage(explicitFeedbacks.map(f => f.rating)),
      preferredWordCount: this.calculatePreferredLength(lowEdit),
      confidence,
    };
  }
  
  private extractPhrases(texts: string[]): string[] {
    // 提取高频短语
    const phrases: Map<string, number> = new Map();
    for (const text of texts) {
      const words = text.split(/\s+/);
      for (let i = 0; i < words.length - 1; i++) {
        const phrase = words.slice(i, i + 3).join(' ');
        phrases.set(phrase, (phrases.get(phrase) || 0) + 1);
      }
    }
    
    return Array.from(phrases.entries())
      .filter(([_, count]) => count >= 2)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([phrase]) => phrase);
  }
  
  private calculateAverage(numbers: number[]): number {
    if (numbers.length === 0) return 0;
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }
}
```

---

### 4.3 方案三：向量化偏好匹配

将用户偏好向量化，通过相似度匹配推荐风格。

**适用场景**：
- 偏好维度多且复杂
- 需要"相似用户"推荐
- 冷启动问题严重

**实现代码**：

```typescript
import { OpenAIEmbeddings } from "@langchain/openai";
import { Chroma } from "@langchain/community/vectorstores/chroma";

class VectorPreferenceService {
  private embeddings: OpenAIEmbeddings;
  private vectorStore: Chroma;
  
  constructor() {
    this.embeddings = new OpenAIEmbeddings();
    this.vectorStore = new Chroma(this.embeddings, {
      collectionName: "user_preferences",
    });
  }
  
  // 将用户偏好向量化并存储
  async storePreferenceVector(userId: string, preference: UserPreference): Promise<void> {
    // 将偏好转换为文本描述
    const preferenceText = this.preferenceToText(preference);
    
    // 向量化并存储
    await this.vectorStore.addDocuments([
      {
        pageContent: preferenceText,
        metadata: {
          userId,
          style: preference.settings.preferredStyle,
          tone: preference.settings.preferredTone,
          updatedAt: new Date().toISOString(),
        },
      },
    ]);
  }
  
  // 查找相似偏好的用户（用于冷启动推荐）
  async findSimilarUsers(userId: string, limit: number = 5): Promise<string[]> {
    const userPreference = await this.getPreferenceVector(userId);
    if (!userPreference) return [];
    
    const results = await this.vectorStore.similaritySearch(
      userPreference,
      limit + 1  // 多取一个，排除自己
    );
    
    return results
      .filter(r => r.metadata.userId !== userId)
      .map(r => r.metadata.userId as string);
  }
  
  // 基于用户描述推荐风格（冷启动）
  async recommendStyleForNewUser(userDescription: string): Promise<string> {
    const results = await this.vectorStore.similaritySearch(userDescription, 3);
    
    // 统计最常见的风格
    const styleCounts = new Map<string, number>();
    for (const result of results) {
      const style = result.metadata.style as string;
      styleCounts.set(style, (styleCounts.get(style) || 0) + 1);
    }
    
    // 返回最常见的风格
    return Array.from(styleCounts.entries())
      .sort((a, b) => b[1] - a[1])[0]?.[0] || 'energetic';
  }
  
  private preferenceToText(preference: UserPreference): string {
    const parts = [
      `风格偏好: ${preference.settings.preferredStyle}`,
      `语气偏好: ${preference.settings.preferredTone}`,
      `长度偏好: ${preference.settings.preferredLength}`,
      `详细程度: ${preference.settings.detailLevel}`,
    ];
    
    if (preference.learned.likedPhrases.length > 0) {
      parts.push(`喜欢的表达: ${preference.learned.likedPhrases.join(', ')}`);
    }
    
    if (preference.learned.dislikedPhrases.length > 0) {
      parts.push(`不喜欢的表达: ${preference.learned.dislikedPhrases.join(', ')}`);
    }
    
    return parts.join('\n');
  }
}
```

---

## 五、偏好应用

### 5.1 Prompt 注入

将用户偏好注入到生成 Prompt 中：

```typescript
function buildPromptWithPreference(
  basePrompt: string,
  preference: UserPreference
): string {
  const preferenceSection = `
## 用户偏好

### 风格要求
- 整体风格: ${preference.settings.preferredStyle}
- 语气: ${preference.settings.preferredTone}
- 长度: ${preference.settings.preferredLength}
- 详细程度: ${preference.settings.detailLevel}

${preference.learned.likedPhrases.length > 0 ? `
### 推荐使用的表达（用户喜欢）
${preference.learned.likedPhrases.map(p => `- "${p}"`).join('\n')}
` : ''}

${preference.learned.dislikedPhrases.length > 0 ? `
### 避免使用的表达（用户不喜欢）
${preference.learned.dislikedPhrases.map(p => `- "${p}"`).join('\n')}
` : ''}

${preference.learned.preferredWordCount > 0 ? `
### 长度参考
目标字数: 约 ${preference.learned.preferredWordCount} 字
` : ''}
`;

  return basePrompt + '\n' + preferenceSection;
}
```

### 5.2 参数动态调整

根据偏好调整生成参数：

```typescript
function getGenerationConfig(preference: UserPreference): GenerationConfig {
  // 基础配置
  const config: GenerationConfig = {
    temperature: 0.7,
    maxTokens: 2000,
    topP: 0.95,
    frequencyPenalty: 0.3,
    presencePenalty: 0.3,
  };
  
  // 根据风格偏好调整温度
  switch (preference.settings.preferredStyle) {
    case 'energetic':
      config.temperature = 0.9;  // 更有创意
      break;
    case 'professional':
      config.temperature = 0.5;  // 更稳定
      break;
    case 'storyteller':
      config.temperature = 0.8;
      break;
  }
  
  // 根据长度偏好调整 maxTokens
  switch (preference.settings.preferredLength) {
    case 'short':
      config.maxTokens = 1000;
      break;
    case 'long':
      config.maxTokens = 4000;
      break;
  }
  
  // 如果用户有明确的长度偏好
  if (preference.learned.preferredWordCount > 0) {
    config.maxTokens = Math.round(preference.learned.preferredWordCount * 1.5);
  }
  
  return config;
}
```

### 5.3 内容后处理

生成后根据偏好进行过滤和调整：

```typescript
function postProcessWithPreference(
  content: string,
  preference: UserPreference
): string {
  let processed = content;
  
  // 1. 移除用户不喜欢的表达
  for (const disliked of preference.learned.dislikedPhrases) {
    const regex = new RegExp(escapeRegExp(disliked), 'gi');
    processed = processed.replace(regex, '');
  }
  
  // 2. 调整 emoji 使用
  if (!preference.settings.useEmoji) {
    processed = removeEmojis(processed);
  }
  
  // 3. 调整长度（如果超出偏好）
  if (preference.learned.preferredWordCount > 0) {
    const currentLength = processed.length;
    const targetLength = preference.learned.preferredWordCount;
    
    if (currentLength > targetLength * 1.3) {
      // 内容过长，尝试精简
      processed = summarizeContent(processed, targetLength);
    }
  }
  
  return processed;
}

function removeEmojis(text: string): string {
  return text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
}

function escapeRegExp(string: string): string {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

---

## 六、反馈收集

### 6.1 显式反馈组件

```tsx
import React, { useState } from 'react';

interface FeedbackFormProps {
  generationId: string;
  onSubmit: (feedback: ExplicitFeedback) => void;
}

function FeedbackForm({ generationId, onSubmit }: FeedbackFormProps) {
  const [rating, setRating] = useState<number>(0);
  const [tags, setTags] = useState<string[]>([]);
  const [comments, setComments] = useState('');
  
  const availableTags = ['太长', '太短', '太正式', '太随意', '很好', '有创意'];
  
  const handleSubmit = () => {
    onSubmit({
      feedbackId: crypto.randomUUID(),
      userId: '', // 从上下文获取
      generationId,
      rating: rating as 1 | 2 | 3 | 4 | 5,
      tags: tags as any,
      comments,
      timestamp: new Date(),
    });
  };
  
  return (
    <div className="feedback-form">
      <h4>对这次生成的内容满意吗？</h4>
      
      {/* 星级评分 */}
      <div className="rating">
        {[1, 2, 3, 4, 5].map((star) => (
          <button
            key={star}
            onClick={() => setRating(star)}
            className={star <= rating ? 'active' : ''}
          >
            ⭐
          </button>
        ))}
      </div>
      
      {/* 快捷标签 */}
      <div className="tags">
        {availableTags.map((tag) => (
          <button
            key={tag}
            onClick={() => {
              setTags(prev => 
                prev.includes(tag) 
                  ? prev.filter(t => t !== tag)
                  : [...prev, tag]
              );
            }}
            className={tags.includes(tag) ? 'selected' : ''}
          >
            {tag}
          </button>
        ))}
      </div>
      
      {/* 文本反馈 */}
      <textarea
        value={comments}
        onChange={(e) => setComments(e.target.value)}
        placeholder="还有其他建议吗？（可选）"
      />
      
      <button onClick={handleSubmit}>提交反馈</button>
    </div>
  );
}
```

### 6.2 隐式反馈追踪

```typescript
class ImplicitFeedbackTracker {
  private generationId: string;
  private startTime: number;
  private originalContent: string;
  private editHistory: string[] = [];
  
  constructor(generationId: string, content: string) {
    this.generationId = generationId;
    this.originalContent = content;
    this.startTime = Date.now();
  }
  
  // 追踪编辑
  trackEdit(newContent: string): void {
    this.editHistory.push(newContent);
  }
  
  // 追踪复制
  trackCopy(): void {
    // 记录复制事件
  }
  
  // 生成隐式反馈
  generateFeedback(): ImplicitFeedback {
    const currentContent = this.editHistory[this.editHistory.length - 1] || this.originalContent;
    const editPercentage = this.calculateEditPercentage(this.originalContent, currentContent);
    const deletedSections = this.findDeletedSections(this.originalContent, currentContent);
    
    return {
      feedbackId: crypto.randomUUID(),
      userId: '', // 从上下文获取
      generationId: this.generationId,
      wasUsed: this.editHistory.length > 0 || editPercentage < 0.5,
      wasCopied: false, // 需要单独追踪
      wasShared: false,
      editPercentage,
      deletedSections,
      modifiedSections: [],
      addedContent: [],
      regenerateCount: 0,
      viewDuration: Math.round((Date.now() - this.startTime) / 1000),
      timestamp: new Date(),
    };
  }
  
  private calculateEditPercentage(original: string, current: string): number {
    const originalWords = original.split(/\s+/);
    const currentWords = current.split(/\s+/);
    
    const commonWords = originalWords.filter(w => currentWords.includes(w));
    return 1 - (commonWords.length / originalWords.length);
  }
  
  private findDeletedSections(original: string, current: string): string[] {
    const originalSentences = original.split(/[。！？\n]+/);
    const currentSentences = current.split(/[。！？\n]+/);
    
    return originalSentences.filter(s => 
      s.trim() && !currentSentences.some(cs => cs.includes(s.trim()))
    );
  }
}
```

---

## 七、实现路线图

### 7.1 阶段规划

| 阶段 | 目标 | 功能 | 技术方案 |
|-----|------|------|---------|
| **P0 MVP** | 基础偏好 | 用户设置、简单应用 | 数据库存储 |
| **P1** | 显式反馈 | 评分收集、反馈分析 | 数据库 + 分析服务 |
| **P2** | 隐式反馈 | 行为追踪、自动学习 | 前端埋点 + 后端分析 |
| **P3** | 长期记忆 | 跨会话偏好、深度学习 | LangGraph MemoryStore |
| **P4** | 智能推荐 | 冷启动、相似用户 | 向量化偏好匹配 |

### 7.2 P0 MVP 实现清单

- [ ] 创建用户偏好数据表
- [ ] 实现偏好设置 API（GET/PUT）
- [ ] 前端偏好设置页面
- [ ] 生成时注入偏好到 Prompt
- [ ] 根据偏好调整温度参数

### 7.3 P1 实现清单

- [ ] 创建反馈记录表
- [ ] 实现反馈提交 API
- [ ] 前端反馈组件（评分 + 标签）
- [ ] 基础反馈统计（平均分、分布）
- [ ] 偏好学习算法 V1（高/低评分分析）

### 7.4 P2 实现清单

- [ ] 前端编辑行为追踪
- [ ] 隐式反馈生成逻辑
- [ ] 删除/修改内容分析
- [ ] 偏好学习算法 V2（结合隐式反馈）

---

## 八、效果评估

### 8.1 评估指标

```typescript
interface PreferenceLearningMetrics {
  // 用户满意度
  averageRating: number;              // 目标: > 4.0
  ratingImprovement: number;          // 学习后评分提升百分比
  
  // 内容采纳率
  usageRate: number;                  // 生成内容实际使用比例
  editRate: number;                   // 平均编辑比例（越低越好）
  
  // 学习效果
  preferenceAccuracy: number;         // 预测偏好的准确率
  personalizationScore: number;       // 个性化程度（不同用户生成内容的差异度）
  
  // 用户行为
  regenerateRate: number;             // 重新生成比例（越低越好）
  feedbackRate: number;               // 用户反馈参与率
}
```

### 8.2 A/B 测试方案

```typescript
// 实验分组
const experimentGroups = {
  control: 'no_preference',           // 对照组：不使用偏好
  treatment_basic: 'basic_preference', // 实验组1：仅使用显式设置
  treatment_full: 'full_preference',   // 实验组2：使用完整偏好学习
};

// 分流逻辑
function getExperimentGroup(userId: string): string {
  const hash = hashCode(userId);
  const bucket = hash % 100;
  
  if (bucket < 20) return 'control';
  if (bucket < 60) return 'treatment_basic';
  return 'treatment_full';
}
```

---

## 九、注意事项

### 9.1 隐私保护

- 用户偏好数据属于个人敏感信息，需要加密存储
- 提供偏好数据导出和删除功能（GDPR 合规）
- 不跨用户使用偏好数据进行推荐（除非用户明确同意）

### 9.2 冷启动处理

- 新用户使用默认偏好设置
- 提供快速偏好问卷（3-5 个问题）
- 基于用户画像（如行业、角色）推荐初始偏好

### 9.3 偏好漂移

- 定期重新计算学习偏好（如每周）
- 给近期反馈更高权重
- 检测偏好突变并提醒用户确认
