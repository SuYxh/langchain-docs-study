# å®æˆ˜é¡¹ç›®å››ï¼šå¤šä»£ç†åä½œå·¥ä½œæµ

åœ¨å‰é¢ä¸‰ä¸ªå®æˆ˜é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«æ¢ç´¢äº†ä»£ç åŠ©æ‰‹ã€ç ”ç©¶åŠ©ç†å’Œå®‰å…¨æ‰§è¡Œå¹³å°ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æŒ‘æˆ˜ç³»åˆ—æ•™ç¨‹çš„ç»ˆæé¡¹ç›®â€”â€”æ„å»ºä¸€ä¸ªå®Œæ•´çš„å¤šä»£ç†åä½œç³»ç»Ÿï¼Œæ¨¡æ‹ŸçœŸå®çš„è½¯ä»¶å¼€å‘å›¢é˜Ÿã€‚

## é¡¹ç›®æ„¿æ™¯

æƒ³è±¡ä¸€ä¸ªAIé©±åŠ¨çš„è½¯ä»¶å¼€å‘å›¢é˜Ÿï¼šäº§å“ç»ç†åˆ†æéœ€æ±‚ã€æ¶æ„å¸ˆè®¾è®¡æ–¹æ¡ˆã€å¼€å‘è€…å®ç°ä»£ç ã€å®¡æŸ¥è€…æŠŠå…³è´¨é‡ã€æµ‹è¯•å‘˜éªŒè¯åŠŸèƒ½ã€‚æ¯ä¸ªè§’è‰²å„å¸å…¶èŒï¼Œåˆç´§å¯†åä½œã€‚è¿™å°±æ˜¯æˆ‘ä»¬è¦æ„å»ºçš„ç³»ç»Ÿã€‚

```
éœ€æ±‚è¾“å…¥ â†’ PMåˆ†æ â†’ æ¶æ„è®¾è®¡ â†’ å¼€å‘å®ç° â†’ ä»£ç å®¡æŸ¥ â†’ æµ‹è¯•éªŒè¯ â†’ äº¤ä»˜
```

## æ¶æ„è®¾è®¡

### å›¢é˜Ÿè§’è‰²å®šä¹‰

```typescript
import {
  createDeepAgent,
  SubAgent,
  CompiledSubAgent,
  StateBackend,
  StoreBackend,
  FilesystemBackend,
  LocalShellBackend,
  CompositeBackend,
} from "@langchain/langgraph-agents";
import { ChatOpenAI } from "@langchain/openai";
import { tool } from "@langchain/core/tools";
import { z } from "zod";
import { MemorySaver } from "@langchain/langgraph";

interface TeamMember {
  name: string;
  role: string;
  responsibilities: string[];
}

const teamStructure: TeamMember[] = [
  {
    name: "product_manager",
    role: "äº§å“ç»ç†",
    responsibilities: ["éœ€æ±‚åˆ†æ", "ä»»åŠ¡æ‹†è§£", "ä¼˜å…ˆçº§æ’åº", "éªŒæ”¶æ ‡å‡†åˆ¶å®š"],
  },
  {
    name: "architect",
    role: "æ¶æ„å¸ˆ",
    responsibilities: ["æŠ€æœ¯é€‰å‹", "ç³»ç»Ÿè®¾è®¡", "æ¥å£å®šä¹‰", "é£é™©è¯„ä¼°"],
  },
  {
    name: "developer",
    role: "å¼€å‘è€…",
    responsibilities: ["ä»£ç å®ç°", "å•å…ƒæµ‹è¯•", "æ–‡æ¡£ç¼–å†™", "Bugä¿®å¤"],
  },
  {
    name: "reviewer",
    role: "ä»£ç å®¡æŸ¥è€…",
    responsibilities: ["ä»£ç å®¡æŸ¥", "æœ€ä½³å®è·µæ£€æŸ¥", "å®‰å…¨æ¼æ´æ£€æµ‹", "æ€§èƒ½åˆ†æ"],
  },
  {
    name: "tester",
    role: "æµ‹è¯•å·¥ç¨‹å¸ˆ",
    responsibilities: ["æµ‹è¯•ç”¨ä¾‹è®¾è®¡", "é›†æˆæµ‹è¯•", "å›å½’æµ‹è¯•", "æµ‹è¯•æŠ¥å‘Š"],
  },
];
```

### å·¥ä½œæµçŠ¶æ€å®šä¹‰

```typescript
interface WorkflowState {
  projectName: string;
  requirement: string;
  currentPhase: WorkflowPhase;
  artifacts: WorkflowArtifacts;
  history: PhaseResult[];
  status: "in_progress" | "blocked" | "completed" | "failed";
}

type WorkflowPhase =
  | "requirement_analysis"
  | "architecture_design"
  | "development"
  | "code_review"
  | "testing"
  | "delivery";

interface WorkflowArtifacts {
  requirementDoc?: RequirementDocument;
  designDoc?: DesignDocument;
  codeFiles?: CodeFile[];
  reviewReport?: ReviewReport;
  testReport?: TestReport;
}

interface RequirementDocument {
  title: string;
  description: string;
  userStories: UserStory[];
  acceptanceCriteria: string[];
  priority: "high" | "medium" | "low";
  estimatedEffort: string;
}

interface UserStory {
  id: string;
  asA: string;
  iWant: string;
  soThat: string;
  acceptanceCriteria: string[];
}

interface DesignDocument {
  overview: string;
  techStack: string[];
  architecture: string;
  components: ComponentDesign[];
  interfaces: InterfaceDefinition[];
  dataModels: DataModel[];
  risks: Risk[];
}

interface ComponentDesign {
  name: string;
  responsibility: string;
  dependencies: string[];
  interfaces: string[];
}

interface InterfaceDefinition {
  name: string;
  method: string;
  endpoint?: string;
  parameters: ParameterDef[];
  response: string;
}

interface ParameterDef {
  name: string;
  type: string;
  required: boolean;
  description: string;
}

interface DataModel {
  name: string;
  fields: FieldDef[];
  relationships: string[];
}

interface FieldDef {
  name: string;
  type: string;
  constraints: string[];
}

interface Risk {
  description: string;
  impact: "high" | "medium" | "low";
  mitigation: string;
}

interface CodeFile {
  path: string;
  content: string;
  language: string;
  tests?: string;
}

interface ReviewReport {
  status: "approved" | "changes_requested" | "rejected";
  summary: string;
  issues: ReviewIssue[];
  suggestions: string[];
  securityConcerns: string[];
}

interface ReviewIssue {
  severity: "critical" | "major" | "minor" | "suggestion";
  file: string;
  line?: number;
  description: string;
  suggestion: string;
}

interface TestReport {
  status: "passed" | "failed" | "partial";
  summary: string;
  testCases: TestCase[];
  coverage: number;
  performanceMetrics?: PerformanceMetric[];
}

interface TestCase {
  name: string;
  status: "passed" | "failed" | "skipped";
  duration: number;
  error?: string;
}

interface PerformanceMetric {
  name: string;
  value: number;
  unit: string;
  threshold?: number;
}

interface PhaseResult {
  phase: WorkflowPhase;
  agent: string;
  startTime: Date;
  endTime: Date;
  status: "success" | "failed" | "blocked";
  output: string;
  artifacts: Partial<WorkflowArtifacts>;
}
```

## å›¢é˜Ÿæˆå‘˜å®ç°

### 1. äº§å“ç»ç†ä»£ç†

```typescript
const requirementAnalysisTool = tool(
  async ({ requirement, context }) => {
    return JSON.stringify({
      status: "analyzed",
      message: "éœ€æ±‚åˆ†æå®Œæˆï¼Œå·²ç”Ÿæˆéœ€æ±‚æ–‡æ¡£",
    });
  },
  {
    name: "analyze_requirement",
    description: "åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œç”Ÿæˆç»“æ„åŒ–çš„éœ€æ±‚æ–‡æ¡£",
    schema: z.object({
      requirement: z.string().describe("åŸå§‹éœ€æ±‚æè¿°"),
      context: z.string().optional().describe("é¡¹ç›®ä¸Šä¸‹æ–‡ä¿¡æ¯"),
    }),
  }
);

const prioritizeTool = tool(
  async ({ items, criteria }) => {
    return JSON.stringify({
      status: "prioritized",
      order: items,
    });
  },
  {
    name: "prioritize_tasks",
    description: "æ ¹æ®ä¸šåŠ¡ä»·å€¼å’ŒæŠ€æœ¯ä¾èµ–å¯¹ä»»åŠ¡è¿›è¡Œä¼˜å…ˆçº§æ’åº",
    schema: z.object({
      items: z.array(z.string()).describe("å¾…æ’åºçš„ä»»åŠ¡åˆ—è¡¨"),
      criteria: z.string().describe("æ’åºæ ‡å‡†"),
    }),
  }
);

const productManagerAgent: SubAgent = {
  name: "product_manager",
  description: `äº§å“ç»ç†ä»£ç†ï¼Œè´Ÿè´£ï¼š
    - åˆ†æå’Œç†è§£ç”¨æˆ·éœ€æ±‚
    - ç¼–å†™ç”¨æˆ·æ•…äº‹å’ŒéªŒæ”¶æ ‡å‡†
    - ä»»åŠ¡æ‹†è§£å’Œä¼˜å…ˆçº§æ’åº
    - åˆ¶å®šé¡¹ç›®é‡Œç¨‹ç¢‘`,
  systemPrompt: `ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„äº§å“ç»ç†ã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. **éœ€æ±‚åˆ†æ**ï¼š
   - æ·±å…¥ç†è§£ç”¨æˆ·éœ€æ±‚çš„æœ¬è´¨
   - è¯†åˆ«å…³é”®åŠŸèƒ½å’ŒéåŠŸèƒ½éœ€æ±‚
   - å‘ç°æ½œåœ¨çš„éœ€æ±‚å†²çªæˆ–é—æ¼

2. **ç”¨æˆ·æ•…äº‹ç¼–å†™**ï¼š
   - ä½¿ç”¨æ ‡å‡†æ ¼å¼ï¼šä½œä¸º[è§’è‰²]ï¼Œæˆ‘æƒ³è¦[åŠŸèƒ½]ï¼Œä»¥ä¾¿[ä»·å€¼]
   - æ¯ä¸ªæ•…äº‹éƒ½è¦æœ‰æ˜ç¡®çš„éªŒæ”¶æ ‡å‡†
   - ä¿æŒæ•…äº‹çš„ç‹¬ç«‹æ€§å’Œå¯æµ‹è¯•æ€§

3. **ä»»åŠ¡æ‹†è§£**ï¼š
   - å°†å¤§éœ€æ±‚æ‹†è§£ä¸ºå¯æ‰§è¡Œçš„å°ä»»åŠ¡
   - è¯†åˆ«ä»»åŠ¡é—´çš„ä¾èµ–å…³ç³»
   - ä¼°ç®—å·¥ä½œé‡

4. **è¾“å‡ºæ ¼å¼**ï¼š
   å§‹ç»ˆä»¥ç»“æ„åŒ–çš„JSONæ ¼å¼è¾“å‡ºéœ€æ±‚æ–‡æ¡£ï¼ŒåŒ…å«ï¼š
   - title: é¡¹ç›®æ ‡é¢˜
   - description: é¡¹ç›®æè¿°
   - userStories: ç”¨æˆ·æ•…äº‹æ•°ç»„
   - acceptanceCriteria: æ•´ä½“éªŒæ”¶æ ‡å‡†
   - priority: ä¼˜å…ˆçº§
   - estimatedEffort: é¢„ä¼°å·¥ä½œé‡`,
  tools: [requirementAnalysisTool, prioritizeTool],
};
```

### 2. æ¶æ„å¸ˆä»£ç†

```typescript
const designSystemTool = tool(
  async ({ requirements, constraints }) => {
    return JSON.stringify({
      status: "designed",
      message: "ç³»ç»Ÿæ¶æ„è®¾è®¡å®Œæˆ",
    });
  },
  {
    name: "design_system",
    description: "æ ¹æ®éœ€æ±‚è®¾è®¡ç³»ç»Ÿæ¶æ„",
    schema: z.object({
      requirements: z.string().describe("éœ€æ±‚æ–‡æ¡£"),
      constraints: z.string().optional().describe("æŠ€æœ¯çº¦æŸ"),
    }),
  }
);

const defineInterfaceTool = tool(
  async ({ componentName, interfaces }) => {
    return JSON.stringify({
      status: "defined",
      interfaces: interfaces,
    });
  },
  {
    name: "define_interface",
    description: "å®šä¹‰ç»„ä»¶æ¥å£",
    schema: z.object({
      componentName: z.string().describe("ç»„ä»¶åç§°"),
      interfaces: z.array(z.string()).describe("æ¥å£å®šä¹‰"),
    }),
  }
);

const assessRiskTool = tool(
  async ({ designDoc }) => {
    return JSON.stringify({
      status: "assessed",
      risks: [],
    });
  },
  {
    name: "assess_risks",
    description: "è¯„ä¼°è®¾è®¡æ–¹æ¡ˆçš„æŠ€æœ¯é£é™©",
    schema: z.object({
      designDoc: z.string().describe("è®¾è®¡æ–‡æ¡£"),
    }),
  }
);

const architectAgent: SubAgent = {
  name: "architect",
  description: `æ¶æ„å¸ˆä»£ç†ï¼Œè´Ÿè´£ï¼š
    - æŠ€æœ¯é€‰å‹å’Œæ¶æ„è®¾è®¡
    - ç»„ä»¶åˆ’åˆ†å’Œæ¥å£å®šä¹‰
    - æ•°æ®æ¨¡å‹è®¾è®¡
    - æŠ€æœ¯é£é™©è¯„ä¼°`,
  systemPrompt: `ä½ æ˜¯ä¸€ä½èµ„æ·±è½¯ä»¶æ¶æ„å¸ˆã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. **æŠ€æœ¯é€‰å‹**ï¼š
   - æ ¹æ®é¡¹ç›®éœ€æ±‚é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆ
   - è€ƒè™‘å›¢é˜ŸæŠ€æœ¯èƒ½åŠ›å’Œå­¦ä¹ æ›²çº¿
   - è¯„ä¼°æŠ€æœ¯çš„æˆç†Ÿåº¦å’Œç¤¾åŒºæ”¯æŒ

2. **æ¶æ„è®¾è®¡**ï¼š
   - è®¾è®¡æ¸…æ™°çš„ç³»ç»Ÿæ¶æ„
   - å®šä¹‰ç»„ä»¶è¾¹ç•Œå’ŒèŒè´£
   - ç¡®ä¿é«˜å†…èšä½è€¦åˆ

3. **æ¥å£å®šä¹‰**ï¼š
   - å®šä¹‰æ¸…æ™°çš„APIæ¥å£
   - ä½¿ç”¨RESTfulæˆ–GraphQLè§„èŒƒ
   - è€ƒè™‘ç‰ˆæœ¬æ§åˆ¶å’Œå‘åå…¼å®¹

4. **æ•°æ®æ¨¡å‹**ï¼š
   - è®¾è®¡åˆç†çš„æ•°æ®ç»“æ„
   - å®šä¹‰å®ä½“å…³ç³»
   - è€ƒè™‘æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§

5. **è¾“å‡ºæ ¼å¼**ï¼š
   å§‹ç»ˆä»¥ç»“æ„åŒ–çš„JSONæ ¼å¼è¾“å‡ºè®¾è®¡æ–‡æ¡£ï¼ŒåŒ…å«ï¼š
   - overview: è®¾è®¡æ¦‚è¿°
   - techStack: æŠ€æœ¯æ ˆ
   - architecture: æ¶æ„æè¿°
   - components: ç»„ä»¶è®¾è®¡
   - interfaces: æ¥å£å®šä¹‰
   - dataModels: æ•°æ®æ¨¡å‹
   - risks: é£é™©è¯„ä¼°`,
  tools: [designSystemTool, defineInterfaceTool, assessRiskTool],
};
```

### 3. å¼€å‘è€…ä»£ç†

```typescript
const writeCodeTool = tool(
  async ({ specification, language }) => {
    return JSON.stringify({
      status: "written",
      message: "ä»£ç ç¼–å†™å®Œæˆ",
    });
  },
  {
    name: "write_code",
    description: "æ ¹æ®è§„èŒƒç¼–å†™ä»£ç ",
    schema: z.object({
      specification: z.string().describe("ä»£ç è§„èŒƒ"),
      language: z.string().describe("ç¼–ç¨‹è¯­è¨€"),
    }),
  }
);

const writeTestTool = tool(
  async ({ codeFile, testFramework }) => {
    return JSON.stringify({
      status: "written",
      message: "æµ‹è¯•ä»£ç ç¼–å†™å®Œæˆ",
    });
  },
  {
    name: "write_tests",
    description: "ä¸ºä»£ç ç¼–å†™å•å…ƒæµ‹è¯•",
    schema: z.object({
      codeFile: z.string().describe("æºä»£ç æ–‡ä»¶"),
      testFramework: z.string().describe("æµ‹è¯•æ¡†æ¶"),
    }),
  }
);

const developerAgent: SubAgent = {
  name: "developer",
  description: `å¼€å‘è€…ä»£ç†ï¼Œè´Ÿè´£ï¼š
    - æ ¹æ®è®¾è®¡æ–‡æ¡£å®ç°ä»£ç 
    - ç¼–å†™å•å…ƒæµ‹è¯•
    - å¤„ç†ä»£ç å®¡æŸ¥åé¦ˆ
    - ä¿®å¤Bug`,
  systemPrompt: `ä½ æ˜¯ä¸€ä½å…¨æ ˆå¼€å‘å·¥ç¨‹å¸ˆã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. **ä»£ç å®ç°**ï¼š
   - ä¸¥æ ¼æŒ‰ç…§è®¾è®¡æ–‡æ¡£å®ç°åŠŸèƒ½
   - éµå¾ªç¼–ç è§„èŒƒå’Œæœ€ä½³å®è·µ
   - ç¼–å†™æ¸…æ™°çš„ä»£ç æ³¨é‡Š
   - å¤„ç†è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯

2. **å•å…ƒæµ‹è¯•**ï¼š
   - ä¸ºæ¯ä¸ªåŠŸèƒ½ç¼–å†™å•å…ƒæµ‹è¯•
   - è¦†ç›–æ­£å¸¸è·¯å¾„å’Œè¾¹ç•Œæƒ…å†µ
   - ä½¿ç”¨Mockéš”ç¦»ä¾èµ–

3. **ä»£ç è´¨é‡**ï¼š
   - ä¿æŒä»£ç ç®€æ´æ˜“è¯»
   - é¿å…é‡å¤ä»£ç 
   - ä½¿ç”¨æœ‰æ„ä¹‰çš„å‘½å

4. **è¾“å‡ºæ ¼å¼**ï¼š
   - æ¯ä¸ªæ–‡ä»¶éƒ½è¦åŒ…å«å®Œæ•´çš„ä»£ç 
   - ä½¿ç”¨æ ‡å‡†çš„é¡¹ç›®ç»“æ„
   - åŒ…å«å¿…è¦çš„é…ç½®æ–‡ä»¶

ç¤ºä¾‹è¾“å‡ºï¼š
\`\`\`typescript
// src/services/user.service.ts
export class UserService {
  async createUser(data: CreateUserDto): Promise<User> {
    // å®ç°ä»£ç 
  }
}
\`\`\``,
  tools: [writeCodeTool, writeTestTool],
  backend: (rt) =>
    new CompositeBackend(new StateBackend(rt), {
      "/workspace/": new FilesystemBackend(rt, {
        workingDirectory: "/tmp/dev-workspace",
      }),
    }),
};
```

### 4. ä»£ç å®¡æŸ¥è€…ä»£ç†

```typescript
const reviewCodeTool = tool(
  async ({ code, standards }) => {
    return JSON.stringify({
      status: "reviewed",
      issues: [],
    });
  },
  {
    name: "review_code",
    description: "å®¡æŸ¥ä»£ç è´¨é‡",
    schema: z.object({
      code: z.string().describe("å¾…å®¡æŸ¥çš„ä»£ç "),
      standards: z.string().optional().describe("å®¡æŸ¥æ ‡å‡†"),
    }),
  }
);

const checkSecurityTool = tool(
  async ({ code }) => {
    return JSON.stringify({
      status: "checked",
      vulnerabilities: [],
    });
  },
  {
    name: "check_security",
    description: "æ£€æŸ¥ä»£ç å®‰å…¨æ¼æ´",
    schema: z.object({
      code: z.string().describe("å¾…æ£€æŸ¥çš„ä»£ç "),
    }),
  }
);

const analyzePerformanceTool = tool(
  async ({ code }) => {
    return JSON.stringify({
      status: "analyzed",
      suggestions: [],
    });
  },
  {
    name: "analyze_performance",
    description: "åˆ†æä»£ç æ€§èƒ½é—®é¢˜",
    schema: z.object({
      code: z.string().describe("å¾…åˆ†æçš„ä»£ç "),
    }),
  }
);

const reviewerAgent: SubAgent = {
  name: "reviewer",
  description: `ä»£ç å®¡æŸ¥è€…ä»£ç†ï¼Œè´Ÿè´£ï¼š
    - ä»£ç è´¨é‡å®¡æŸ¥
    - å®‰å…¨æ¼æ´æ£€æµ‹
    - æ€§èƒ½é—®é¢˜åˆ†æ
    - æœ€ä½³å®è·µå»ºè®®`,
  systemPrompt: `ä½ æ˜¯ä¸€ä½ä¸¥è°¨çš„ä»£ç å®¡æŸ¥ä¸“å®¶ã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. **ä»£ç è´¨é‡å®¡æŸ¥**ï¼š
   - æ£€æŸ¥ä»£ç æ˜¯å¦ç¬¦åˆè®¾è®¡è§„èŒƒ
   - éªŒè¯é€»è¾‘æ­£ç¡®æ€§
   - è¯„ä¼°ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
   - æ£€æŸ¥é”™è¯¯å¤„ç†æ˜¯å¦å®Œå–„

2. **å®‰å…¨å®¡æŸ¥**ï¼š
   - æ£€æŸ¥å¸¸è§å®‰å…¨æ¼æ´ï¼ˆSQLæ³¨å…¥ã€XSSç­‰ï¼‰
   - éªŒè¯è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç 
   - æ£€æŸ¥æ•æ„Ÿæ•°æ®å¤„ç†
   - è¯„ä¼°è®¤è¯å’Œæˆæƒé€»è¾‘

3. **æ€§èƒ½å®¡æŸ¥**ï¼š
   - è¯†åˆ«æ½œåœ¨çš„æ€§èƒ½ç“¶é¢ˆ
   - æ£€æŸ¥N+1æŸ¥è¯¢é—®é¢˜
   - è¯„ä¼°å†…å­˜ä½¿ç”¨
   - æ£€æŸ¥å¼‚æ­¥æ“ä½œå¤„ç†

4. **è¾“å‡ºæ ¼å¼**ï¼š
   å§‹ç»ˆä»¥ç»“æ„åŒ–çš„JSONæ ¼å¼è¾“å‡ºå®¡æŸ¥æŠ¥å‘Šï¼ŒåŒ…å«ï¼š
   - status: "approved" | "changes_requested" | "rejected"
   - summary: å®¡æŸ¥æ€»ç»“
   - issues: é—®é¢˜åˆ—è¡¨ï¼ˆåŒ…å«severity, file, line, description, suggestionï¼‰
   - suggestions: æ”¹è¿›å»ºè®®
   - securityConcerns: å®‰å…¨é—®é¢˜`,
  tools: [reviewCodeTool, checkSecurityTool, analyzePerformanceTool],
};
```

### 5. æµ‹è¯•å·¥ç¨‹å¸ˆä»£ç†

```typescript
const runTestsTool = tool(
  async ({ testFiles, config }) => {
    return JSON.stringify({
      status: "completed",
      results: [],
    });
  },
  {
    name: "run_tests",
    description: "æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹",
    schema: z.object({
      testFiles: z.array(z.string()).describe("æµ‹è¯•æ–‡ä»¶åˆ—è¡¨"),
      config: z.string().optional().describe("æµ‹è¯•é…ç½®"),
    }),
  }
);

const generateTestCasesTool = tool(
  async ({ requirements, code }) => {
    return JSON.stringify({
      status: "generated",
      testCases: [],
    });
  },
  {
    name: "generate_test_cases",
    description: "æ ¹æ®éœ€æ±‚ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹",
    schema: z.object({
      requirements: z.string().describe("éœ€æ±‚æ–‡æ¡£"),
      code: z.string().describe("å®ç°ä»£ç "),
    }),
  }
);

const measureCoverageTool = tool(
  async ({ testResults }) => {
    return JSON.stringify({
      coverage: 0,
      uncoveredLines: [],
    });
  },
  {
    name: "measure_coverage",
    description: "æµ‹é‡æµ‹è¯•è¦†ç›–ç‡",
    schema: z.object({
      testResults: z.string().describe("æµ‹è¯•ç»“æœ"),
    }),
  }
);

const testerAgent: SubAgent = {
  name: "tester",
  description: `æµ‹è¯•å·¥ç¨‹å¸ˆä»£ç†ï¼Œè´Ÿè´£ï¼š
    - è®¾è®¡æµ‹è¯•ç”¨ä¾‹
    - æ‰§è¡Œé›†æˆæµ‹è¯•
    - å›å½’æµ‹è¯•
    - ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š`,
  systemPrompt: `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æµ‹è¯•å·¥ç¨‹å¸ˆã€‚ä½ çš„èŒè´£æ˜¯ï¼š

1. **æµ‹è¯•ç”¨ä¾‹è®¾è®¡**ï¼š
   - æ ¹æ®éœ€æ±‚è®¾è®¡æµ‹è¯•ç”¨ä¾‹
   - è¦†ç›–æ­£å¸¸æµç¨‹å’Œå¼‚å¸¸æµç¨‹
   - è®¾è®¡è¾¹ç•Œæ¡ä»¶æµ‹è¯•
   - åŒ…å«æ€§èƒ½æµ‹è¯•åœºæ™¯

2. **æµ‹è¯•æ‰§è¡Œ**ï¼š
   - æ‰§è¡Œå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
   - éªŒè¯åŠŸèƒ½æ˜¯å¦ç¬¦åˆéœ€æ±‚
   - æ£€æŸ¥å›å½’é—®é¢˜
   - è¿›è¡Œæ¢ç´¢æ€§æµ‹è¯•

3. **æµ‹è¯•æŠ¥å‘Š**ï¼š
   - è®°å½•æµ‹è¯•ç»“æœ
   - åˆ†æå¤±è´¥åŸå› 
   - è®¡ç®—æµ‹è¯•è¦†ç›–ç‡
   - æä¾›è´¨é‡è¯„ä¼°

4. **è¾“å‡ºæ ¼å¼**ï¼š
   å§‹ç»ˆä»¥ç»“æ„åŒ–çš„JSONæ ¼å¼è¾“å‡ºæµ‹è¯•æŠ¥å‘Šï¼ŒåŒ…å«ï¼š
   - status: "passed" | "failed" | "partial"
   - summary: æµ‹è¯•æ€»ç»“
   - testCases: æµ‹è¯•ç”¨ä¾‹ç»“æœ
   - coverage: è¦†ç›–ç‡
   - performanceMetrics: æ€§èƒ½æŒ‡æ ‡`,
  tools: [runTestsTool, generateTestCasesTool, measureCoverageTool],
  backend: (rt) =>
    new CompositeBackend(new StateBackend(rt), {
      "/test-results/": new StoreBackend(rt, {
        namespace: ["test", "results"],
      }),
    }),
};
```

## å·¥ä½œæµåè°ƒå™¨

### ä¸»ä»£ç†å®šä¹‰

```typescript
const workflowCoordinatorTool = tool(
  async ({ phase, input }) => {
    return JSON.stringify({
      status: "coordinated",
      nextPhase: phase,
    });
  },
  {
    name: "coordinate_workflow",
    description: "åè°ƒå·¥ä½œæµé˜¶æ®µè½¬æ¢",
    schema: z.object({
      phase: z.enum([
        "requirement_analysis",
        "architecture_design",
        "development",
        "code_review",
        "testing",
        "delivery",
      ]),
      input: z.string().describe("é˜¶æ®µè¾“å…¥"),
    }),
  }
);

const escalateIssueTool = tool(
  async ({ issue, severity }) => {
    return JSON.stringify({
      status: "escalated",
      action: "human_review",
    });
  },
  {
    name: "escalate_issue",
    description: "å‡çº§é—®é¢˜åˆ°äººå·¥å¤„ç†",
    schema: z.object({
      issue: z.string().describe("é—®é¢˜æè¿°"),
      severity: z.enum(["critical", "high", "medium", "low"]),
    }),
  }
);

const generateReportTool = tool(
  async ({ workflowState }) => {
    return JSON.stringify({
      status: "generated",
      report: {},
    });
  },
  {
    name: "generate_report",
    description: "ç”Ÿæˆå·¥ä½œæµæŠ¥å‘Š",
    schema: z.object({
      workflowState: z.string().describe("å·¥ä½œæµçŠ¶æ€"),
    }),
  }
);

const createTeamCoordinator = () => {
  const checkpointer = new MemorySaver();

  return createDeepAgent({
    model: new ChatOpenAI({
      modelName: "gpt-4",
      temperature: 0,
    }),
    systemPrompt: `ä½ æ˜¯è½¯ä»¶å¼€å‘å›¢é˜Ÿçš„é¡¹ç›®åè°ƒå‘˜ã€‚ä½ è´Ÿè´£ï¼š

1. **å·¥ä½œæµç®¡ç†**ï¼š
   - åè°ƒå„ä¸ªå¼€å‘é˜¶æ®µçš„æ‰§è¡Œé¡ºåº
   - ç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„è¾“å‡ºæ»¡è¶³ä¸‹ä¸€é˜¶æ®µçš„è¾“å…¥è¦æ±‚
   - å¤„ç†é˜¶æ®µé—´çš„ä¾èµ–å…³ç³»

2. **å›¢é˜Ÿåè°ƒ**ï¼š
   - å°†ä»»åŠ¡åˆ†é…ç»™åˆé€‚çš„å›¢é˜Ÿæˆå‘˜
   - æ”¶é›†å’Œæ•´åˆå„æˆå‘˜çš„è¾“å‡º
   - è§£å†³å›¢é˜Ÿé—´çš„å†²çª

3. **è´¨é‡æŠŠæ§**ï¼š
   - ç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„äº¤ä»˜ç‰©ç¬¦åˆæ ‡å‡†
   - åœ¨å…³é”®èŠ‚ç‚¹è¿›è¡Œå®¡æ‰¹
   - å¤„ç†å¼‚å¸¸æƒ…å†µ

4. **å·¥ä½œæµç¨‹**ï¼š
   éœ€æ±‚è¾“å…¥ â†’ äº§å“ç»ç†åˆ†æ â†’ æ¶æ„å¸ˆè®¾è®¡ â†’ å¼€å‘è€…å®ç° â†’ å®¡æŸ¥è€…å®¡æŸ¥ â†’ æµ‹è¯•å‘˜æµ‹è¯• â†’ äº¤ä»˜

5. **å†³ç­–è§„åˆ™**ï¼š
   - å¦‚æœä»£ç å®¡æŸ¥ä¸é€šè¿‡ï¼Œè¿”å›å¼€å‘é˜¶æ®µ
   - å¦‚æœæµ‹è¯•ä¸é€šè¿‡ï¼Œæ ¹æ®é—®é¢˜æ€§è´¨å†³å®šè¿”å›å¼€å‘æˆ–å®¡æŸ¥é˜¶æ®µ
   - å…³é”®å†³ç­–éœ€è¦äººå·¥ç¡®è®¤

å§‹ç»ˆè¾“å‡ºæ¸…æ™°çš„çŠ¶æ€æ›´æ–°å’Œä¸‹ä¸€æ­¥è¡ŒåŠ¨è®¡åˆ’ã€‚`,

    tools: [workflowCoordinatorTool, escalateIssueTool, generateReportTool],

    subagents: [
      productManagerAgent,
      architectAgent,
      developerAgent,
      reviewerAgent,
      testerAgent,
    ],

    backend: (rt) =>
      new CompositeBackend(new StateBackend(rt), {
        "/project/": new FilesystemBackend(rt, {
          workingDirectory: "/tmp/project-workspace",
        }),
        "/memories/": new StoreBackend(rt, {
          namespace: ["workflow", "history"],
        }),
      }),

    interruptOn: [
      {
        toolName: "task",
        condition: (toolCall) => {
          const args = toolCall.args as { name: string };
          return args.name === "developer";
        },
      },
      {
        toolName: "escalate_issue",
      },
    ],

    checkpointer,
  });
};
```

## å·¥ä½œæµæ‰§è¡Œå¼•æ“

### é˜¶æ®µæ‰§è¡Œå™¨

```typescript
interface PhaseExecutor {
  execute(input: PhaseInput): Promise<PhaseOutput>;
}

interface PhaseInput {
  workflowState: WorkflowState;
  previousOutput?: PhaseResult;
}

interface PhaseOutput {
  status: "success" | "failed" | "blocked";
  artifacts: Partial<WorkflowArtifacts>;
  message: string;
  nextPhase?: WorkflowPhase;
}

class RequirementPhaseExecutor implements PhaseExecutor {
  constructor(private coordinator: ReturnType<typeof createTeamCoordinator>) {}

  async execute(input: PhaseInput): Promise<PhaseOutput> {
    const result = await this.coordinator.invoke({
      messages: [
        {
          role: "user",
          content: `è¯·è®©äº§å“ç»ç†åˆ†æä»¥ä¸‹éœ€æ±‚ï¼Œå¹¶ç”Ÿæˆéœ€æ±‚æ–‡æ¡£ï¼š

é¡¹ç›®åç§°ï¼š${input.workflowState.projectName}
åŸå§‹éœ€æ±‚ï¼š${input.workflowState.requirement}

è¦æ±‚ï¼š
1. ç”Ÿæˆç»“æ„åŒ–çš„éœ€æ±‚æ–‡æ¡£
2. åŒ…å«ç”¨æˆ·æ•…äº‹å’ŒéªŒæ”¶æ ‡å‡†
3. è¿›è¡Œä»»åŠ¡æ‹†è§£å’Œä¼˜å…ˆçº§æ’åº`,
        },
      ],
    });

    const requirementDoc = this.parseRequirementDoc(result);

    return {
      status: "success",
      artifacts: { requirementDoc },
      message: "éœ€æ±‚åˆ†æå®Œæˆ",
      nextPhase: "architecture_design",
    };
  }

  private parseRequirementDoc(result: any): RequirementDocument {
    return {
      title: "",
      description: "",
      userStories: [],
      acceptanceCriteria: [],
      priority: "medium",
      estimatedEffort: "",
    };
  }
}

class DesignPhaseExecutor implements PhaseExecutor {
  constructor(private coordinator: ReturnType<typeof createTeamCoordinator>) {}

  async execute(input: PhaseInput): Promise<PhaseOutput> {
    const requirementDoc = input.workflowState.artifacts.requirementDoc;

    const result = await this.coordinator.invoke({
      messages: [
        {
          role: "user",
          content: `è¯·è®©æ¶æ„å¸ˆæ ¹æ®ä»¥ä¸‹éœ€æ±‚è®¾è®¡ç³»ç»Ÿæ¶æ„ï¼š

éœ€æ±‚æ–‡æ¡£ï¼š
${JSON.stringify(requirementDoc, null, 2)}

è¦æ±‚ï¼š
1. é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆ
2. è®¾è®¡ç³»ç»Ÿæ¶æ„å’Œç»„ä»¶
3. å®šä¹‰æ¥å£å’Œæ•°æ®æ¨¡å‹
4. è¯„ä¼°æŠ€æœ¯é£é™©`,
        },
      ],
    });

    const designDoc = this.parseDesignDoc(result);

    return {
      status: "success",
      artifacts: { designDoc },
      message: "æ¶æ„è®¾è®¡å®Œæˆ",
      nextPhase: "development",
    };
  }

  private parseDesignDoc(result: any): DesignDocument {
    return {
      overview: "",
      techStack: [],
      architecture: "",
      components: [],
      interfaces: [],
      dataModels: [],
      risks: [],
    };
  }
}

class DevelopmentPhaseExecutor implements PhaseExecutor {
  constructor(private coordinator: ReturnType<typeof createTeamCoordinator>) {}

  async execute(input: PhaseInput): Promise<PhaseOutput> {
    const { requirementDoc, designDoc } = input.workflowState.artifacts;

    const result = await this.coordinator.invoke({
      messages: [
        {
          role: "user",
          content: `è¯·è®©å¼€å‘è€…æ ¹æ®è®¾è®¡æ–‡æ¡£å®ç°ä»£ç ï¼š

éœ€æ±‚æ–‡æ¡£ï¼š
${JSON.stringify(requirementDoc, null, 2)}

è®¾è®¡æ–‡æ¡£ï¼š
${JSON.stringify(designDoc, null, 2)}

è¦æ±‚ï¼š
1. ä¸¥æ ¼æŒ‰ç…§è®¾è®¡æ–‡æ¡£å®ç°
2. ç¼–å†™å•å…ƒæµ‹è¯•
3. éµå¾ªç¼–ç è§„èŒƒ`,
        },
      ],
    });

    const codeFiles = this.parseCodeFiles(result);

    return {
      status: "success",
      artifacts: { codeFiles },
      message: "ä»£ç å¼€å‘å®Œæˆ",
      nextPhase: "code_review",
    };
  }

  private parseCodeFiles(result: any): CodeFile[] {
    return [];
  }
}

class ReviewPhaseExecutor implements PhaseExecutor {
  constructor(private coordinator: ReturnType<typeof createTeamCoordinator>) {}

  async execute(input: PhaseInput): Promise<PhaseOutput> {
    const { codeFiles, designDoc } = input.workflowState.artifacts;

    const result = await this.coordinator.invoke({
      messages: [
        {
          role: "user",
          content: `è¯·è®©ä»£ç å®¡æŸ¥è€…å®¡æŸ¥ä»¥ä¸‹ä»£ç ï¼š

ä»£ç æ–‡ä»¶ï¼š
${JSON.stringify(codeFiles, null, 2)}

è®¾è®¡æ–‡æ¡£ï¼š
${JSON.stringify(designDoc, null, 2)}

å®¡æŸ¥è¦ç‚¹ï¼š
1. ä»£ç è´¨é‡å’Œè§„èŒƒ
2. å®‰å…¨æ¼æ´æ£€æµ‹
3. æ€§èƒ½é—®é¢˜åˆ†æ
4. æ˜¯å¦ç¬¦åˆè®¾è®¡è§„èŒƒ`,
        },
      ],
    });

    const reviewReport = this.parseReviewReport(result);

    if (reviewReport.status === "rejected") {
      return {
        status: "blocked",
        artifacts: { reviewReport },
        message: "ä»£ç å®¡æŸ¥æœªé€šè¿‡ï¼Œéœ€è¦ä¿®æ”¹",
        nextPhase: "development",
      };
    }

    return {
      status: "success",
      artifacts: { reviewReport },
      message:
        reviewReport.status === "approved" ? "ä»£ç å®¡æŸ¥é€šè¿‡" : "ä»£ç éœ€è¦ä¿®æ”¹",
      nextPhase:
        reviewReport.status === "approved" ? "testing" : "development",
    };
  }

  private parseReviewReport(result: any): ReviewReport {
    return {
      status: "approved",
      summary: "",
      issues: [],
      suggestions: [],
      securityConcerns: [],
    };
  }
}

class TestingPhaseExecutor implements PhaseExecutor {
  constructor(private coordinator: ReturnType<typeof createTeamCoordinator>) {}

  async execute(input: PhaseInput): Promise<PhaseOutput> {
    const { codeFiles, requirementDoc } = input.workflowState.artifacts;

    const result = await this.coordinator.invoke({
      messages: [
        {
          role: "user",
          content: `è¯·è®©æµ‹è¯•å·¥ç¨‹å¸ˆæ‰§è¡Œæµ‹è¯•ï¼š

ä»£ç æ–‡ä»¶ï¼š
${JSON.stringify(codeFiles, null, 2)}

éœ€æ±‚æ–‡æ¡£ï¼š
${JSON.stringify(requirementDoc, null, 2)}

æµ‹è¯•è¦æ±‚ï¼š
1. è®¾è®¡æµ‹è¯•ç”¨ä¾‹
2. æ‰§è¡ŒåŠŸèƒ½æµ‹è¯•
3. æµ‹é‡ä»£ç è¦†ç›–ç‡
4. ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š`,
        },
      ],
    });

    const testReport = this.parseTestReport(result);

    if (testReport.status === "failed") {
      return {
        status: "blocked",
        artifacts: { testReport },
        message: "æµ‹è¯•æœªé€šè¿‡",
        nextPhase: "development",
      };
    }

    return {
      status: "success",
      artifacts: { testReport },
      message: "æµ‹è¯•é€šè¿‡",
      nextPhase: "delivery",
    };
  }

  private parseTestReport(result: any): TestReport {
    return {
      status: "passed",
      summary: "",
      testCases: [],
      coverage: 0,
    };
  }
}
```

### å·¥ä½œæµå¼•æ“

```typescript
class WorkflowEngine {
  private executors: Map<WorkflowPhase, PhaseExecutor>;
  private coordinator: ReturnType<typeof createTeamCoordinator>;

  constructor() {
    this.coordinator = createTeamCoordinator();
    this.executors = new Map([
      ["requirement_analysis", new RequirementPhaseExecutor(this.coordinator)],
      ["architecture_design", new DesignPhaseExecutor(this.coordinator)],
      ["development", new DevelopmentPhaseExecutor(this.coordinator)],
      ["code_review", new ReviewPhaseExecutor(this.coordinator)],
      ["testing", new TestingPhaseExecutor(this.coordinator)],
    ]);
  }

  async run(
    projectName: string,
    requirement: string
  ): Promise<WorkflowState> {
    const state: WorkflowState = {
      projectName,
      requirement,
      currentPhase: "requirement_analysis",
      artifacts: {},
      history: [],
      status: "in_progress",
    };

    const phaseOrder: WorkflowPhase[] = [
      "requirement_analysis",
      "architecture_design",
      "development",
      "code_review",
      "testing",
      "delivery",
    ];

    let currentIndex = 0;
    let maxIterations = 10;
    let iterations = 0;

    while (
      state.currentPhase !== "delivery" &&
      iterations < maxIterations
    ) {
      iterations++;
      const executor = this.executors.get(state.currentPhase);

      if (!executor) {
        throw new Error(`No executor for phase: ${state.currentPhase}`);
      }

      console.log(`\n${"=".repeat(60)}`);
      console.log(`æ‰§è¡Œé˜¶æ®µ: ${state.currentPhase}`);
      console.log(`${"=".repeat(60)}\n`);

      const startTime = new Date();
      const output = await executor.execute({
        workflowState: state,
        previousOutput: state.history[state.history.length - 1],
      });
      const endTime = new Date();

      state.artifacts = { ...state.artifacts, ...output.artifacts };
      state.history.push({
        phase: state.currentPhase,
        agent: this.getAgentForPhase(state.currentPhase),
        startTime,
        endTime,
        status: output.status,
        output: output.message,
        artifacts: output.artifacts,
      });

      if (output.status === "failed") {
        state.status = "failed";
        break;
      }

      if (output.nextPhase) {
        state.currentPhase = output.nextPhase;
      } else {
        currentIndex++;
        if (currentIndex < phaseOrder.length) {
          state.currentPhase = phaseOrder[currentIndex];
        }
      }

      console.log(`é˜¶æ®µç»“æœ: ${output.status}`);
      console.log(`æ¶ˆæ¯: ${output.message}`);
      console.log(`ä¸‹ä¸€é˜¶æ®µ: ${state.currentPhase}`);
    }

    if (state.currentPhase === "delivery") {
      state.status = "completed";
    }

    return state;
  }

  private getAgentForPhase(phase: WorkflowPhase): string {
    const mapping: Record<WorkflowPhase, string> = {
      requirement_analysis: "product_manager",
      architecture_design: "architect",
      development: "developer",
      code_review: "reviewer",
      testing: "tester",
      delivery: "coordinator",
    };
    return mapping[phase];
  }

  async *streamRun(
    projectName: string,
    requirement: string
  ): AsyncGenerator<WorkflowStreamEvent> {
    const state: WorkflowState = {
      projectName,
      requirement,
      currentPhase: "requirement_analysis",
      artifacts: {},
      history: [],
      status: "in_progress",
    };

    yield {
      type: "workflow_started",
      data: { projectName, requirement },
    };

    const phaseOrder: WorkflowPhase[] = [
      "requirement_analysis",
      "architecture_design",
      "development",
      "code_review",
      "testing",
      "delivery",
    ];

    while (state.currentPhase !== "delivery") {
      yield {
        type: "phase_started",
        data: {
          phase: state.currentPhase,
          agent: this.getAgentForPhase(state.currentPhase),
        },
      };

      const executor = this.executors.get(state.currentPhase);
      if (!executor) break;

      const output = await executor.execute({ workflowState: state });

      yield {
        type: "phase_completed",
        data: {
          phase: state.currentPhase,
          status: output.status,
          message: output.message,
          artifacts: output.artifacts,
        },
      };

      state.artifacts = { ...state.artifacts, ...output.artifacts };

      if (output.status === "failed") {
        yield { type: "workflow_failed", data: { reason: output.message } };
        return;
      }

      if (output.nextPhase) {
        state.currentPhase = output.nextPhase;
      }
    }

    yield {
      type: "workflow_completed",
      data: { state },
    };
  }
}

interface WorkflowStreamEvent {
  type:
    | "workflow_started"
    | "phase_started"
    | "phase_completed"
    | "workflow_completed"
    | "workflow_failed";
  data: any;
}
```

## å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

### å¯åŠ¨å·¥ä½œæµ

```typescript
async function main() {
  const engine = new WorkflowEngine();

  const projectName = "ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ";
  const requirement = `
    æ„å»ºä¸€ä¸ªç”¨æˆ·ç®¡ç†ç³»ç»Ÿï¼Œéœ€è¦æ”¯æŒï¼š
    1. ç”¨æˆ·æ³¨å†Œå’Œç™»å½•ï¼ˆé‚®ç®±/æ‰‹æœºå·ï¼‰
    2. ç”¨æˆ·ä¿¡æ¯ç®¡ç†ï¼ˆæŸ¥çœ‹ã€ç¼–è¾‘ä¸ªäººèµ„æ–™ï¼‰
    3. å¯†ç é‡ç½®åŠŸèƒ½
    4. è§’è‰²æƒé™ç®¡ç†ï¼ˆç®¡ç†å‘˜ã€æ™®é€šç”¨æˆ·ï¼‰
    5. æ“ä½œæ—¥å¿—è®°å½•
    
    æŠ€æœ¯è¦æ±‚ï¼š
    - åç«¯ä½¿ç”¨ Node.js + TypeScript
    - æ•°æ®åº“ä½¿ç”¨ PostgreSQL
    - æä¾› RESTful API
    - éœ€è¦å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè¾“å…¥éªŒè¯
  `;

  console.log("ğŸš€ å¯åŠ¨è½¯ä»¶å¼€å‘å·¥ä½œæµ\n");
  console.log(`é¡¹ç›®: ${projectName}`);
  console.log(`éœ€æ±‚: ${requirement}\n`);

  const finalState = await engine.run(projectName, requirement);

  console.log("\n" + "=".repeat(60));
  console.log("ğŸ“Š å·¥ä½œæµæ‰§è¡ŒæŠ¥å‘Š");
  console.log("=".repeat(60));
  console.log(`çŠ¶æ€: ${finalState.status}`);
  console.log(`é˜¶æ®µå†å²:`);

  for (const phase of finalState.history) {
    console.log(`  - ${phase.phase}: ${phase.status} (${phase.agent})`);
    console.log(`    ${phase.output}`);
  }
}

main().catch(console.error);
```

### æµå¼æ‰§è¡Œç¤ºä¾‹

```typescript
async function streamExample() {
  const engine = new WorkflowEngine();

  const projectName = "åšå®¢ç³»ç»Ÿ";
  const requirement = `
    æ„å»ºä¸€ä¸ªç®€å•çš„åšå®¢ç³»ç»Ÿï¼š
    1. æ–‡ç« çš„åˆ›å»ºã€ç¼–è¾‘ã€åˆ é™¤
    2. æ–‡ç« åˆ†ç±»å’Œæ ‡ç­¾
    3. è¯„è®ºåŠŸèƒ½
    4. ç”¨æˆ·è®¤è¯
  `;

  console.log("ğŸš€ å¯åŠ¨æµå¼å·¥ä½œæµ\n");

  for await (const event of engine.streamRun(projectName, requirement)) {
    switch (event.type) {
      case "workflow_started":
        console.log(`ğŸ“ é¡¹ç›®å¯åŠ¨: ${event.data.projectName}`);
        break;

      case "phase_started":
        console.log(`\nâ³ é˜¶æ®µå¼€å§‹: ${event.data.phase}`);
        console.log(`   è´Ÿè´£äºº: ${event.data.agent}`);
        break;

      case "phase_completed":
        console.log(`âœ… é˜¶æ®µå®Œæˆ: ${event.data.phase}`);
        console.log(`   çŠ¶æ€: ${event.data.status}`);
        console.log(`   ${event.data.message}`);
        break;

      case "workflow_completed":
        console.log("\nğŸ‰ å·¥ä½œæµå®Œæˆ!");
        break;

      case "workflow_failed":
        console.log(`\nâŒ å·¥ä½œæµå¤±è´¥: ${event.data.reason}`);
        break;
    }
  }
}
```

## å‰ç«¯é›†æˆ

### React ç»„ä»¶

```typescript
import React, { useState } from "react";
import { useStream } from "@langchain/langgraph-sdk/react";

interface TeamMemberStatus {
  name: string;
  role: string;
  status: "idle" | "working" | "completed" | "blocked";
  currentTask?: string;
  output?: string;
}

function WorkflowDashboard() {
  const [requirement, setRequirement] = useState("");
  const [projectName, setProjectName] = useState("");

  const { messages, subagentStreams, isLoading, submit } = useStream<{
    messages: any[];
    workflow_state?: WorkflowState;
  }>({
    assistantId: "team-coordinator",
    filterSubagentMessages: true,
  });

  const teamMembers: TeamMemberStatus[] = [
    { name: "product_manager", role: "äº§å“ç»ç†", status: "idle" },
    { name: "architect", role: "æ¶æ„å¸ˆ", status: "idle" },
    { name: "developer", role: "å¼€å‘è€…", status: "idle" },
    { name: "reviewer", role: "å®¡æŸ¥è€…", status: "idle" },
    { name: "tester", role: "æµ‹è¯•å‘˜", status: "idle" },
  ].map((member) => {
    const stream = subagentStreams.find((s) => s.name === member.name);
    if (stream) {
      return {
        ...member,
        status: stream.status === "running" ? "working" : "completed",
        currentTask: stream.currentToolCall?.name,
        output: stream.messages[stream.messages.length - 1]?.content,
      };
    }
    return member;
  });

  const handleSubmit = () => {
    submit({
      messages: [
        {
          role: "user",
          content: `é¡¹ç›®åç§°: ${projectName}\n\néœ€æ±‚æè¿°:\n${requirement}`,
        },
      ],
    });
  };

  return (
    <div className="workflow-dashboard">
      <header className="dashboard-header">
        <h1>ğŸ¢ AI è½¯ä»¶å¼€å‘å›¢é˜Ÿ</h1>
        <p>å¤šä»£ç†åä½œå·¥ä½œæµæ¼”ç¤º</p>
      </header>

      <div className="input-section">
        <div className="form-group">
          <label>é¡¹ç›®åç§°</label>
          <input
            type="text"
            value={projectName}
            onChange={(e) => setProjectName(e.target.value)}
            placeholder="è¾“å…¥é¡¹ç›®åç§°..."
          />
        </div>
        <div className="form-group">
          <label>éœ€æ±‚æè¿°</label>
          <textarea
            value={requirement}
            onChange={(e) => setRequirement(e.target.value)}
            placeholder="æè¿°ä½ çš„éœ€æ±‚..."
            rows={6}
          />
        </div>
        <button
          onClick={handleSubmit}
          disabled={isLoading || !requirement || !projectName}
        >
          {isLoading ? "å¤„ç†ä¸­..." : "ğŸš€ å¯åŠ¨å·¥ä½œæµ"}
        </button>
      </div>

      <div className="team-section">
        <h2>ğŸ‘¥ å›¢é˜ŸçŠ¶æ€</h2>
        <div className="team-grid">
          {teamMembers.map((member) => (
            <TeamMemberCard key={member.name} member={member} />
          ))}
        </div>
      </div>

      <div className="workflow-section">
        <h2>ğŸ“‹ å·¥ä½œæµè¿›åº¦</h2>
        <WorkflowTimeline
          phases={[
            "requirement_analysis",
            "architecture_design",
            "development",
            "code_review",
            "testing",
            "delivery",
          ]}
          currentPhase={
            messages[messages.length - 1]?.workflow_state?.currentPhase
          }
          history={messages[messages.length - 1]?.workflow_state?.history || []}
        />
      </div>

      <div className="artifacts-section">
        <h2>ğŸ“¦ äº¤ä»˜ç‰©</h2>
        <ArtifactViewer
          artifacts={
            messages[messages.length - 1]?.workflow_state?.artifacts || {}
          }
        />
      </div>
    </div>
  );
}

function TeamMemberCard({ member }: { member: TeamMemberStatus }) {
  const statusIcons: Record<TeamMemberStatus["status"], string> = {
    idle: "âšª",
    working: "ğŸ”µ",
    completed: "ğŸŸ¢",
    blocked: "ğŸ”´",
  };

  const roleIcons: Record<string, string> = {
    äº§å“ç»ç†: "ğŸ“‹",
    æ¶æ„å¸ˆ: "ğŸ—ï¸",
    å¼€å‘è€…: "ğŸ’»",
    å®¡æŸ¥è€…: "ğŸ”",
    æµ‹è¯•å‘˜: "ğŸ§ª",
  };

  return (
    <div className={`team-member-card ${member.status}`}>
      <div className="member-header">
        <span className="role-icon">{roleIcons[member.role]}</span>
        <span className="status-icon">{statusIcons[member.status]}</span>
      </div>
      <h3>{member.role}</h3>
      <p className="member-name">{member.name}</p>
      {member.currentTask && (
        <p className="current-task">å½“å‰ä»»åŠ¡: {member.currentTask}</p>
      )}
      {member.output && (
        <div className="member-output">
          <pre>{member.output.substring(0, 200)}...</pre>
        </div>
      )}
    </div>
  );
}

function WorkflowTimeline({
  phases,
  currentPhase,
  history,
}: {
  phases: WorkflowPhase[];
  currentPhase?: WorkflowPhase;
  history: PhaseResult[];
}) {
  const phaseNames: Record<WorkflowPhase, string> = {
    requirement_analysis: "éœ€æ±‚åˆ†æ",
    architecture_design: "æ¶æ„è®¾è®¡",
    development: "å¼€å‘å®ç°",
    code_review: "ä»£ç å®¡æŸ¥",
    testing: "æµ‹è¯•éªŒè¯",
    delivery: "äº¤ä»˜",
  };

  const getPhaseStatus = (phase: WorkflowPhase) => {
    if (phase === currentPhase) return "current";
    const result = history.find((h) => h.phase === phase);
    if (result) {
      return result.status === "success" ? "completed" : "failed";
    }
    return "pending";
  };

  return (
    <div className="workflow-timeline">
      {phases.map((phase, index) => (
        <React.Fragment key={phase}>
          <div className={`timeline-node ${getPhaseStatus(phase)}`}>
            <div className="node-circle">
              {getPhaseStatus(phase) === "completed"
                ? "âœ“"
                : getPhaseStatus(phase) === "current"
                  ? "â—"
                  : index + 1}
            </div>
            <div className="node-label">{phaseNames[phase]}</div>
          </div>
          {index < phases.length - 1 && (
            <div
              className={`timeline-connector ${
                getPhaseStatus(phases[index + 1]) !== "pending"
                  ? "active"
                  : ""
              }`}
            />
          )}
        </React.Fragment>
      ))}
    </div>
  );
}

function ArtifactViewer({ artifacts }: { artifacts: WorkflowArtifacts }) {
  const [activeTab, setActiveTab] = useState<string>("requirement");

  const tabs = [
    { id: "requirement", label: "éœ€æ±‚æ–‡æ¡£", data: artifacts.requirementDoc },
    { id: "design", label: "è®¾è®¡æ–‡æ¡£", data: artifacts.designDoc },
    { id: "code", label: "ä»£ç æ–‡ä»¶", data: artifacts.codeFiles },
    { id: "review", label: "å®¡æŸ¥æŠ¥å‘Š", data: artifacts.reviewReport },
    { id: "test", label: "æµ‹è¯•æŠ¥å‘Š", data: artifacts.testReport },
  ];

  return (
    <div className="artifact-viewer">
      <div className="artifact-tabs">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            className={`tab ${activeTab === tab.id ? "active" : ""} ${
              tab.data ? "has-data" : ""
            }`}
            onClick={() => setActiveTab(tab.id)}
          >
            {tab.label}
            {tab.data && <span className="badge">âœ“</span>}
          </button>
        ))}
      </div>
      <div className="artifact-content">
        {tabs.find((t) => t.id === activeTab)?.data ? (
          <pre>
            {JSON.stringify(
              tabs.find((t) => t.id === activeTab)?.data,
              null,
              2
            )}
          </pre>
        ) : (
          <p className="empty-state">æš‚æ— æ•°æ®</p>
        )}
      </div>
    </div>
  );
}

export default WorkflowDashboard;
```

### æ ·å¼å®šä¹‰

```css
/* workflow-dashboard.css */
.workflow-dashboard {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.dashboard-header {
  text-align: center;
  margin-bottom: 2rem;
}

.dashboard-header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
}

.input-section {
  background: #f8f9fa;
  padding: 2rem;
  border-radius: 12px;
  margin-bottom: 2rem;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 1rem;
}

.input-section button {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 1rem 2rem;
  border-radius: 8px;
  font-size: 1.1rem;
  cursor: pointer;
  width: 100%;
}

.input-section button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.team-section {
  margin-bottom: 2rem;
}

.team-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 1rem;
}

.team-member-card {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s, box-shadow 0.2s;
}

.team-member-card.working {
  border: 2px solid #667eea;
  animation: pulse 2s infinite;
}

.team-member-card.completed {
  border: 2px solid #10b981;
}

.team-member-card.blocked {
  border: 2px solid #ef4444;
}

@keyframes pulse {
  0%,
  100% {
    box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.4);
  }
  50% {
    box-shadow: 0 0 0 10px rgba(102, 126, 234, 0);
  }
}

.member-header {
  display: flex;
  justify-content: space-between;
  font-size: 1.5rem;
  margin-bottom: 0.5rem;
}

.workflow-timeline {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 2rem 0;
}

.timeline-node {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 0 0 auto;
}

.node-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.timeline-node.current .node-circle {
  background: #667eea;
  color: white;
  animation: pulse 2s infinite;
}

.timeline-node.completed .node-circle {
  background: #10b981;
  color: white;
}

.timeline-node.failed .node-circle {
  background: #ef4444;
  color: white;
}

.timeline-connector {
  flex: 1;
  height: 3px;
  background: #e5e7eb;
  margin: 0 0.5rem;
}

.timeline-connector.active {
  background: #10b981;
}

.artifact-viewer {
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.artifact-tabs {
  display: flex;
  border-bottom: 1px solid #e5e7eb;
}

.artifact-tabs .tab {
  flex: 1;
  padding: 1rem;
  border: none;
  background: none;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background 0.2s;
}

.artifact-tabs .tab:hover {
  background: #f8f9fa;
}

.artifact-tabs .tab.active {
  border-bottom: 2px solid #667eea;
  color: #667eea;
}

.artifact-tabs .tab .badge {
  margin-left: 0.5rem;
  color: #10b981;
}

.artifact-content {
  padding: 1.5rem;
  max-height: 400px;
  overflow-y: auto;
}

.artifact-content pre {
  background: #f8f9fa;
  padding: 1rem;
  border-radius: 8px;
  font-size: 0.85rem;
  white-space: pre-wrap;
}

.empty-state {
  text-align: center;
  color: #9ca3af;
  padding: 2rem;
}
```

## é«˜çº§ç‰¹æ€§

### å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ

```typescript
class ParallelWorkflowEngine extends WorkflowEngine {
  async runParallelPhase(
    state: WorkflowState,
    agents: string[],
    task: string
  ): Promise<PhaseOutput[]> {
    const promises = agents.map((agentName) =>
      this.coordinator.invoke({
        messages: [
          {
            role: "user",
            content: `è¯·è®© ${agentName} æ‰§è¡Œä»»åŠ¡: ${task}`,
          },
        ],
      })
    );

    const results = await Promise.all(promises);
    return results.map((result) => ({
      status: "success" as const,
      artifacts: {},
      message: "å¹¶è¡Œä»»åŠ¡å®Œæˆ",
    }));
  }

  async runWithParallelReview(
    projectName: string,
    requirement: string
  ): Promise<WorkflowState> {
    const state = await this.run(projectName, requirement);

    if (state.currentPhase === "code_review") {
      const [securityReview, performanceReview, codeQualityReview] =
        await this.runParallelPhase(
          state,
          ["security_reviewer", "performance_reviewer", "quality_reviewer"],
          "å®¡æŸ¥ä»£ç "
        );

      state.artifacts.reviewReport = {
        status: "approved",
        summary: "å¤šç»´åº¦å®¡æŸ¥å®Œæˆ",
        issues: [],
        suggestions: [],
        securityConcerns: [],
      };
    }

    return state;
  }
}
```

### å·¥ä½œæµæŒä¹…åŒ–

```typescript
import { PostgresSaver } from "@langchain/langgraph/checkpoint/postgres";

class PersistentWorkflowEngine extends WorkflowEngine {
  private checkpointer: PostgresSaver;

  constructor() {
    super();
    this.checkpointer = PostgresSaver.fromConnString(
      process.env.DATABASE_URL!
    );
  }

  async saveWorkflowState(
    threadId: string,
    state: WorkflowState
  ): Promise<void> {
    await this.checkpointer.put(
      { configurable: { thread_id: threadId } },
      {
        values: state,
        next: [],
        tasks: [],
        metadata: {},
      },
      { source: "update", step: 0, writes: {} },
      {}
    );
  }

  async loadWorkflowState(threadId: string): Promise<WorkflowState | null> {
    const checkpoint = await this.checkpointer.get({
      configurable: { thread_id: threadId },
    });
    return checkpoint?.values as WorkflowState | null;
  }

  async resumeWorkflow(threadId: string): Promise<WorkflowState> {
    const state = await this.loadWorkflowState(threadId);
    if (!state) {
      throw new Error(`No workflow found for thread: ${threadId}`);
    }

    console.log(`æ¢å¤å·¥ä½œæµï¼Œå½“å‰é˜¶æ®µ: ${state.currentPhase}`);
    return this.continueRun(state);
  }

  private async continueRun(state: WorkflowState): Promise<WorkflowState> {
    while (state.currentPhase !== "delivery" && state.status === "in_progress") {
      const executor = this.executors.get(state.currentPhase);
      if (!executor) break;

      const output = await executor.execute({ workflowState: state });
      state.artifacts = { ...state.artifacts, ...output.artifacts };

      if (output.nextPhase) {
        state.currentPhase = output.nextPhase;
      }

      await this.saveWorkflowState(state.projectName, state);
    }

    return state;
  }
}
```

## ç³»åˆ—æ€»ç»“

æ­å–œä½ å®Œæˆäº† DeepAgents ç³»åˆ—æ•™ç¨‹çš„å…¨éƒ¨ 22 ç¯‡æ–‡ç« ï¼è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹å­¦ä¹ å†ç¨‹ï¼š

### çŸ¥è¯†å›¾è°±

```
DeepAgents çŸ¥è¯†ä½“ç³»
â”œâ”€â”€ åŸºç¡€å…¥é—¨ (æ–‡ç«  1-3)
â”‚   â”œâ”€â”€ æ ¸å¿ƒæ¦‚å¿µå’Œ API
â”‚   â”œâ”€â”€ å¿«é€Ÿå¼€å§‹
â”‚   â””â”€â”€ è‡ªå®šä¹‰é…ç½®
â”œâ”€â”€ åç«¯ç³»ç»Ÿ (æ–‡ç«  4-6)
â”‚   â”œâ”€â”€ è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ äº”ç§åç«¯ç±»å‹
â”‚   â””â”€â”€ CompositeBackend
â”œâ”€â”€ é«˜çº§åŠŸèƒ½ (æ–‡ç«  7-10)
â”‚   â”œâ”€â”€ å­ä»£ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ äººæœºåä½œ
â”‚   â”œâ”€â”€ é•¿æœŸè®°å¿†
â”‚   â””â”€â”€ æŠ€èƒ½ç³»ç»Ÿ
â”œâ”€â”€ å®‰å…¨æ‰§è¡Œ (æ–‡ç«  11-12)
â”‚   â”œâ”€â”€ æ²™ç®±æ¦‚è§ˆ
â”‚   â””â”€â”€ æ²™ç®±å®æˆ˜
â”œâ”€â”€ æµå¼å¤„ç† (æ–‡ç«  13-14)
â”‚   â”œâ”€â”€ æµå¼è¾“å‡º
â”‚   â””â”€â”€ å‰ç«¯é›†æˆ
â”œâ”€â”€ CLI å·¥å…· (æ–‡ç«  15-16)
â”‚   â”œâ”€â”€ CLI å…¥é—¨
â”‚   â””â”€â”€ é«˜çº§ç”¨æ³•
â”œâ”€â”€ è¿›é˜¶é…ç½® (æ–‡ç«  17-18)
â”‚   â”œâ”€â”€ ä¸­é—´ä»¶ç³»ç»Ÿ
â”‚   â””â”€â”€ è‡ªå®šä¹‰æ¨¡å‹
â””â”€â”€ é¡¹ç›®å®æˆ˜ (æ–‡ç«  19-22)
    â”œâ”€â”€ æ™ºèƒ½ä»£ç åŠ©æ‰‹
    â”œâ”€â”€ ç ”ç©¶åŠ©ç†ç³»ç»Ÿ
    â”œâ”€â”€ å®‰å…¨æ‰§è¡Œå¹³å°
    â””â”€â”€ å¤šä»£ç†åä½œ â† ä½ åœ¨è¿™é‡Œ
```

### æ ¸å¿ƒèƒ½åŠ›æ€»ç»“

| èƒ½åŠ› | å…³é”®æŠ€æœ¯ | åº”ç”¨åœºæ™¯ |
|------|----------|----------|
| ä»»åŠ¡è§„åˆ’ | TodoListMiddleware | å¤æ‚ä»»åŠ¡åˆ†è§£ |
| ä¸Šä¸‹æ–‡ç®¡ç† | CompositeBackend | å¤šæºæ•°æ®æ•´åˆ |
| å­ä»£ç†åä½œ | SubAgent/CompiledSubAgent | ä¸“ä¸šåŒ–åˆ†å·¥ |
| é•¿æœŸè®°å¿† | StoreBackend | çŸ¥è¯†ç§¯ç´¯ |
| å®‰å…¨æ‰§è¡Œ | Sandbox | ä»£ç è¿è¡Œ |
| äººæœºåä½œ | interrupt_on | å…³é”®å†³ç­– |
| æµå¼è¾“å‡º | streamMode/useStream | å®æ—¶äº¤äº’ |

### ä¸‹ä¸€æ­¥å»ºè®®

1. **åŠ¨æ‰‹å®è·µ**: é€‰æ‹©ä¸€ä¸ªå®æˆ˜é¡¹ç›®ï¼Œä»é›¶å¼€å§‹æ„å»º
2. **æ·±å…¥æºç **: é˜…è¯» DeepAgents æºç ï¼Œç†è§£å†…éƒ¨å®ç°
3. **ç¤¾åŒºå‚ä¸**: åŠ å…¥ç¤¾åŒºï¼Œåˆ†äº«ç»éªŒï¼Œè´¡çŒ®ä»£ç 
4. **æŒç»­å­¦ä¹ **: å…³æ³¨ DeepAgents æ›´æ–°ï¼Œå­¦ä¹ æ–°ç‰¹æ€§

æ„Ÿè°¢ä½ çš„å­¦ä¹ ï¼ŒæœŸå¾…çœ‹åˆ°ä½ æ„å»ºçš„ AI ä»£ç†åº”ç”¨ï¼ğŸš€
