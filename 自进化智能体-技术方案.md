# è‡ªè¿›åŒ–æ™ºèƒ½ä½“ - æŠ€æœ¯æ–¹æ¡ˆ

## ä¸€ã€æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯è‡ªè¿›åŒ–æ™ºèƒ½ä½“ï¼Ÿ

è‡ªè¿›åŒ–æ™ºèƒ½ä½“ï¼ˆSelf-Evolving Agentï¼‰æ˜¯æŒ‡å…·å¤‡è‡ªæˆ‘å­¦ä¹ ã€è‡ªæˆ‘åæ€ã€è‡ªæˆ‘ä¼˜åŒ–èƒ½åŠ›çš„ AI æ™ºèƒ½ä½“ã€‚ä¸ä¼ ç»Ÿçš„é™æ€æ™ºèƒ½ä½“ä¸åŒï¼Œè‡ªè¿›åŒ–æ™ºèƒ½ä½“èƒ½å¤Ÿï¼š

- ä»å†å²äº¤äº’ä¸­å­¦ä¹ ç»éªŒ
- è¯„ä¼°è‡ªå·±çš„è¾“å‡ºè´¨é‡å¹¶è¿­ä»£æ”¹è¿›
- æ ¹æ®åé¦ˆè‡ªåŠ¨ä¼˜åŒ–ç­–ç•¥
- ç§¯ç´¯çŸ¥è¯†å½¢æˆé•¿æœŸè®°å¿†

### 1.2 èƒ½åŠ›é‡‘å­—å¡”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ™ºèƒ½ä½“è‡ªæˆ‘è¿›åŒ–èƒ½åŠ›é‡‘å­—å¡”                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚  Level 4  â”‚  ğŸ”´ ä»£ç è‡ªæ”¹ï¼ˆç›®å‰éš¾ä»¥å®ç°ï¼‰
                          â”‚ æ¶æ„è¿›åŒ–  â”‚  è‡ªå·±ä¿®æ”¹è‡ªå·±çš„ä»£ç /æ¶æ„
                          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                â”‚
                          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                          â”‚  Level 3  â”‚  ğŸŸ¡ ç­–ç•¥è‡ªä¼˜åŒ–ï¼ˆå¯å®ç°ï¼Œéœ€è°¨æ…ï¼‰
                          â”‚Promptä¼˜åŒ– â”‚  è‡ªåŠ¨ä¼˜åŒ– Prompt/å†³ç­–ç­–ç•¥
                          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚       Level 2         â”‚  ğŸŸ¢ ç»éªŒå­¦ä¹ ï¼ˆå®Œå…¨å¯å®ç°ï¼‰
                    â”‚     é•¿æœŸè®°å¿†/RAG       â”‚  ä»å†å²ä¸­å­¦ä¹ ï¼Œç§¯ç´¯ç»éªŒ
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   Level 1                     â”‚  ğŸŸ¢ è‡ªæˆ‘åæ€ï¼ˆå®Œå…¨å¯å®ç°ï¼‰
        â”‚              Reflection/Critique              â”‚  è¯„ä¼°è¾“å‡ºï¼Œè¿­ä»£æ”¹è¿›
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 æŠ€æœ¯é€‰å‹

| æŠ€æœ¯ | è§’è‰² | å¿…è¦æ€§ |
|-----|------|-------|
| **LangGraph** | æ„å»ºå¤æ‚çš„å­¦ä¹ å¾ªç¯å’ŒçŠ¶æ€ç®¡ç† | â­ å¼ºçƒˆæ¨è |
| **LangChain** | åŸºç¡€ LLM è°ƒç”¨å’Œå·¥å…·é›†æˆ | âœ… å¿…è¦ |
| **å‘é‡æ•°æ®åº“** | å­˜å‚¨ç»éªŒå’ŒçŸ¥è¯† | âœ… å¿…è¦ |
| **é•¿æœŸè®°å¿† (MemoryStore)** | è·¨ä¼šè¯çŠ¶æ€æŒä¹…åŒ– | â­ æ¨è |
| **å…³ç³»å‹æ•°æ®åº“** | å­˜å‚¨ç»“æ„åŒ–å­¦ä¹ æ•°æ® | å¯é€‰ |

---

## äºŒã€ç³»ç»Ÿæ¶æ„

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          è‡ªè¿›åŒ–æ™ºèƒ½ä½“æ¶æ„                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                              ç”¨æˆ·è¾“å…¥
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              æ ¸å¿ƒæ‰§è¡Œå±‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   ä»»åŠ¡ç†è§£   â”‚â”€â”€â”€â–¶â”‚   è®¡åˆ’ç”Ÿæˆ   â”‚â”€â”€â”€â–¶â”‚   æ‰§è¡Œä»»åŠ¡   â”‚â”€â”€â”€â–¶â”‚   è¾“å‡ºç”Ÿæˆ   â”‚  â”‚
â”‚  â”‚   Agent     â”‚    â”‚   Agent     â”‚    â”‚   Agent     â”‚    â”‚   Agent     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                     â”‚                   â”‚         â”‚
â”‚         â–¼                                     â–¼                   â–¼         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         ç»éªŒæ£€ç´¢ (RAG)                               â”‚   â”‚
â”‚  â”‚              æ£€ç´¢ç›¸å…³å†å²ç»éªŒï¼Œæ³¨å…¥åˆ°æ‰§è¡Œä¸Šä¸‹æ–‡                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              åæ€å±‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚   è´¨é‡è¯„ä¼°   â”‚â”€â”€â”€â–¶â”‚   é—®é¢˜è¯Šæ–­   â”‚â”€â”€â”€â–¶â”‚   æ”¹è¿›å»ºè®®   â”‚                     â”‚
â”‚  â”‚  Evaluator  â”‚    â”‚  Diagnoser  â”‚    â”‚  Improver   â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                               â”‚                             â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                          â”‚  æ˜¯å¦éœ€è¦é‡æ–°ç”Ÿæˆï¼Ÿ                       â”‚        â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                     â”‚                   â”‚                   â”‚
â”‚                                  æ˜¯ â”‚                   â”‚ å¦                â”‚
â”‚                                     â–¼                   â–¼                   â”‚
â”‚                           è¿”å›æ‰§è¡Œå±‚é‡æ–°ç”Ÿæˆ        è¿›å…¥å­¦ä¹ å±‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                          â”‚
                                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              å­¦ä¹ å±‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ç»éªŒæå–   â”‚â”€â”€â”€â–¶â”‚  æ¨¡å¼è¯†åˆ«   â”‚â”€â”€â”€â–¶â”‚  ç­–ç•¥æ›´æ–°   â”‚â”€â”€â”€â–¶â”‚  çŸ¥è¯†å­˜å‚¨   â”‚  â”‚
â”‚  â”‚ Experience  â”‚    â”‚  Pattern    â”‚    â”‚  Strategy   â”‚    â”‚  Knowledge  â”‚  â”‚
â”‚  â”‚  Extractor  â”‚    â”‚  Recognizer â”‚    â”‚  Updater    â”‚    â”‚   Store     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                          â”‚
                                                          â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚            çŸ¥è¯†åº“                    â”‚
                              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
                              â”‚  â”‚ â€¢ ç»éªŒå‘é‡åº“ (æˆåŠŸ/å¤±è´¥æ¡ˆä¾‹)  â”‚    â”‚
                              â”‚  â”‚ â€¢ Prompt ç‰ˆæœ¬åº“              â”‚    â”‚
                              â”‚  â”‚ â€¢ å·¥å…·ä½¿ç”¨æ¨¡å¼åº“             â”‚    â”‚
                              â”‚  â”‚ â€¢ ç”¨æˆ·åå¥½åº“                 â”‚    â”‚
                              â”‚  â”‚ â€¢ ç­–ç•¥è§„åˆ™åº“                 â”‚    â”‚
                              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            å­¦ä¹ é—­ç¯æ•°æ®æµ                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  è¾“å…¥    â”‚ â”€â”€â”€â”€â”€â”€â–¶ â”‚  æ‰§è¡Œ    â”‚ â”€â”€â”€â”€â”€â”€â–¶ â”‚  è¾“å‡º    â”‚
     â”‚  ä»»åŠ¡    â”‚         â”‚  ä»»åŠ¡    â”‚         â”‚  ç»“æœ    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â–²                    â”‚                    â”‚
          â”‚                    â”‚ ç»éªŒæ£€ç´¢           â”‚
          â”‚                    â–¼                    â”‚
          â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
          â”‚              â”‚  çŸ¥è¯†åº“  â”‚               â”‚
          â”‚              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜               â”‚
          â”‚                   â”‚                     â”‚
          â”‚                   â”‚ çŸ¥è¯†æ›´æ–°            â”‚
          â”‚                   â–¼                     â–¼
     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  ç­–ç•¥    â”‚ â—€â”€â”€â”€â”€â”€ â”‚  å­¦ä¹     â”‚ â—€â”€â”€â”€â”€â”€â”€ â”‚  åé¦ˆ    â”‚
     â”‚  æ›´æ–°    â”‚        â”‚  åˆ†æ    â”‚         â”‚  æ”¶é›†    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€Level 1: è‡ªæˆ‘åæ€ (Reflection)

### 3.1 æ¦‚è¿°

è‡ªæˆ‘åæ€æ˜¯æœ€åŸºç¡€çš„è‡ªè¿›åŒ–èƒ½åŠ›ï¼ŒæŒ‡æ™ºèƒ½ä½“èƒ½å¤Ÿè¯„ä¼°è‡ªå·±çš„è¾“å‡ºè´¨é‡ï¼Œå‘ç°é—®é¢˜å¹¶è¿›è¡Œè¿­ä»£æ”¹è¿›ã€‚

### 3.2 åæ€æ¨¡å¼

#### æ¨¡å¼ä¸€ï¼šç”Ÿæˆ-æ‰¹è¯„-æ”¹è¿›å¾ªç¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”Ÿæˆ    â”‚â”€â”€â”€â”€â–¶â”‚  æ‰¹è¯„    â”‚â”€â”€â”€â”€â–¶â”‚  æ”¹è¿›    â”‚
â”‚ Generate â”‚     â”‚ Critique â”‚     â”‚ Improve  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                      â”‚                 â”‚
                      â”‚    ä¸æ»¡æ„       â”‚ æ»¡æ„
                      â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  è¾“å‡º    â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ¨¡å¼äºŒï¼šå¤šè§†è§’è¯„ä¼°

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  ç”Ÿæˆ    â”‚
                    â”‚  è¾“å‡º    â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼              â–¼              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ å‡†ç¡®æ€§   â”‚   â”‚ å®Œæ•´æ€§   â”‚   â”‚ é£æ ¼     â”‚
    â”‚ è¯„ä¼°     â”‚   â”‚ è¯„ä¼°     â”‚   â”‚ è¯„ä¼°     â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â”‚              â”‚              â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ ç»¼åˆè¯„åˆ† â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 LangGraph å®ç°

```typescript
import { StateGraph, Annotation, END } from "@langchain/langgraph";
import { ChatOpenAI } from "@langchain/openai";

// çŠ¶æ€å®šä¹‰
const ReflectionState = Annotation.Root({
  task: Annotation<string>,
  draft: Annotation<string>,
  critique: Annotation<string>,
  score: Annotation<number>,
  finalOutput: Annotation<string>,
  iterationCount: Annotation<number>,
  maxIterations: Annotation<number>,
});

const llm = new ChatOpenAI({ model: "gpt-4" });

// ç”ŸæˆèŠ‚ç‚¹
async function generate(state: typeof ReflectionState.State) {
  const hasCritique = state.critique && state.critique.length > 0;
  
  const prompt = hasCritique
    ? `
      ä»»åŠ¡: ${state.task}
      
      ä½ ä¹‹å‰çš„è¾“å‡ºå­˜åœ¨ä»¥ä¸‹é—®é¢˜:
      ${state.critique}
      
      è¯·æ ¹æ®åé¦ˆæ”¹è¿›ä½ çš„è¾“å‡º:
    `
    : `
      ä»»åŠ¡: ${state.task}
      
      è¯·å®Œæˆä¸Šè¿°ä»»åŠ¡:
    `;
  
  const response = await llm.invoke(prompt);
  
  return {
    draft: response.content as string,
    iterationCount: state.iterationCount + 1,
  };
}

// è¯„ä¼°èŠ‚ç‚¹
async function evaluate(state: typeof ReflectionState.State) {
  const evaluationPrompt = `
    ä½ æ˜¯ä¸€ä¸ªä¸¥æ ¼çš„è´¨é‡è¯„ä¼°ä¸“å®¶ã€‚è¯„ä¼°ä»¥ä¸‹è¾“å‡ºçš„è´¨é‡ã€‚
    
    ## ä»»åŠ¡
    ${state.task}
    
    ## è¾“å‡º
    ${state.draft}
    
    ## è¯„ä¼°ç»´åº¦
    1. å‡†ç¡®æ€§ (0-10): å†…å®¹æ˜¯å¦æ­£ç¡®
    2. å®Œæ•´æ€§ (0-10): æ˜¯å¦æ¶µç›–æ‰€æœ‰è¦ç‚¹
    3. æ¸…æ™°åº¦ (0-10): è¡¨è¾¾æ˜¯å¦æ¸…æ™°æ˜“æ‡‚
    4. ç›¸å…³æ€§ (0-10): æ˜¯å¦ç´§æ‰£ä¸»é¢˜
    
    ## è¾“å‡ºæ ¼å¼
    è¯·æŒ‰ä»¥ä¸‹ JSON æ ¼å¼è¾“å‡º:
    {
      "scores": {
        "accuracy": <åˆ†æ•°>,
        "completeness": <åˆ†æ•°>,
        "clarity": <åˆ†æ•°>,
        "relevance": <åˆ†æ•°>
      },
      "overall": <æ€»åˆ† 0-10>,
      "critique": "<å¦‚æœæ€»åˆ†<8ï¼Œè¯¦ç»†è¯´æ˜é—®é¢˜å’Œæ”¹è¿›å»ºè®®ï¼›å¦åˆ™è¾“å‡º APPROVED>"
    }
  `;
  
  const response = await llm.invoke(evaluationPrompt);
  const evaluation = JSON.parse(response.content as string);
  
  return {
    score: evaluation.overall,
    critique: evaluation.critique,
  };
}

// æœ€ç»ˆåŒ–èŠ‚ç‚¹
async function finalize(state: typeof ReflectionState.State) {
  return {
    finalOutput: state.draft,
  };
}

// è·¯ç”±å‡½æ•°
function shouldContinue(state: typeof ReflectionState.State): "generate" | "finalize" {
  // è´¨é‡è¾¾æ ‡æˆ–è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°
  if (state.score >= 8 || state.critique === "APPROVED") {
    return "finalize";
  }
  
  if (state.iterationCount >= state.maxIterations) {
    console.warn(`è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•° ${state.maxIterations}ï¼Œå¼ºåˆ¶ç»“æŸ`);
    return "finalize";
  }
  
  return "generate";
}

// æ„å»ºå›¾
const reflectionGraph = new StateGraph(ReflectionState)
  .addNode("generate", generate)
  .addNode("evaluate", evaluate)
  .addNode("finalize", finalize)
  .addEdge("__start__", "generate")
  .addEdge("generate", "evaluate")
  .addConditionalEdges("evaluate", shouldContinue, {
    generate: "generate",
    finalize: "finalize",
  })
  .addEdge("finalize", "__end__")
  .compile();

// ä½¿ç”¨ç¤ºä¾‹
async function runReflection(task: string) {
  const result = await reflectionGraph.invoke({
    task,
    draft: "",
    critique: "",
    score: 0,
    finalOutput: "",
    iterationCount: 0,
    maxIterations: 3,
  });
  
  console.log(`è¿­ä»£æ¬¡æ•°: ${result.iterationCount}`);
  console.log(`æœ€ç»ˆå¾—åˆ†: ${result.score}`);
  console.log(`è¾“å‡º: ${result.finalOutput}`);
  
  return result.finalOutput;
}
```

### 3.4 é«˜çº§åæ€æ¨¡å¼ï¼šå¤š Agent åä½œè¯„ä¼°

```typescript
// å¤šè§’è‰²è¯„ä¼°ç³»ç»Ÿ
const EvaluationTeam = {
  // äº‹å®æ ¸æŸ¥å‘˜
  factChecker: async (output: string, context: string) => {
    return await llm.invoke(`
      ä½ æ˜¯äº‹å®æ ¸æŸ¥ä¸“å®¶ã€‚æ£€æŸ¥ä»¥ä¸‹å†…å®¹çš„äº‹å®å‡†ç¡®æ€§:
      ${output}
      
      èƒŒæ™¯ä¿¡æ¯: ${context}
      
      åˆ—å‡ºæ‰€æœ‰äº‹å®é”™è¯¯ï¼ˆå¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå›å¤"æ— äº‹å®é”™è¯¯"ï¼‰
    `);
  },
  
  // é€»è¾‘åˆ†æå¸ˆ
  logicAnalyzer: async (output: string) => {
    return await llm.invoke(`
      ä½ æ˜¯é€»è¾‘åˆ†æä¸“å®¶ã€‚åˆ†æä»¥ä¸‹å†…å®¹çš„é€»è¾‘ä¸€è‡´æ€§:
      ${output}
      
      æ£€æŸ¥:
      1. è®ºç‚¹æ˜¯å¦æœ‰é€»è¾‘æ”¯æ’‘
      2. æ˜¯å¦å­˜åœ¨è‡ªç›¸çŸ›ç›¾
      3. æ¨ç†è¿‡ç¨‹æ˜¯å¦åˆç†
      
      åˆ—å‡ºæ‰€æœ‰é€»è¾‘é—®é¢˜ï¼ˆå¦‚æœæ²¡æœ‰é—®é¢˜ï¼Œå›å¤"é€»è¾‘æ¸…æ™°"ï¼‰
    `);
  },
  
  // é£æ ¼ç¼–è¾‘
  styleEditor: async (output: string, targetStyle: string) => {
    return await llm.invoke(`
      ä½ æ˜¯èµ„æ·±ç¼–è¾‘ã€‚è¯„ä¼°ä»¥ä¸‹å†…å®¹çš„è¡¨è¾¾é£æ ¼:
      ${output}
      
      ç›®æ ‡é£æ ¼: ${targetStyle}
      
      è¯„ä¼°:
      1. è¯­è¨€æ˜¯å¦æµç•…
      2. é£æ ¼æ˜¯å¦åŒ¹é…
      3. æ˜¯å¦æœ‰å†—ä½™è¡¨è¾¾
      
      åˆ—å‡ºæ”¹è¿›å»ºè®®ï¼ˆå¦‚æœé£æ ¼è‰¯å¥½ï¼Œå›å¤"é£æ ¼åˆé€‚"ï¼‰
    `);
  },
};

// ç»¼åˆå¤šä¸ªè¯„ä¼°ç»“æœ
async function multiPerspectiveEvaluation(
  output: string,
  context: string,
  targetStyle: string
) {
  const [factResult, logicResult, styleResult] = await Promise.all([
    EvaluationTeam.factChecker(output, context),
    EvaluationTeam.logicAnalyzer(output),
    EvaluationTeam.styleEditor(output, targetStyle),
  ]);
  
  // ç»¼åˆè¯„ä¼°
  const synthesisPrompt = `
    ç»¼åˆä»¥ä¸‹è¯„ä¼°ç»“æœï¼Œç»™å‡ºæœ€ç»ˆè¯„ä»·å’Œæ”¹è¿›å»ºè®®:
    
    ## äº‹å®æ ¸æŸ¥ç»“æœ
    ${factResult.content}
    
    ## é€»è¾‘åˆ†æç»“æœ
    ${logicResult.content}
    
    ## é£æ ¼è¯„ä¼°ç»“æœ
    ${styleResult.content}
    
    è¯·è¾“å‡º:
    1. æ€»ä½“è¯„åˆ† (0-10)
    2. ä¸»è¦é—®é¢˜åˆ—è¡¨
    3. ä¼˜å…ˆæ”¹è¿›å»ºè®®
  `;
  
  return await llm.invoke(synthesisPrompt);
}
```

---

## å››ã€Level 2: ç»éªŒå­¦ä¹  (Experience Learning)

### 4.1 æ¦‚è¿°

ç»éªŒå­¦ä¹ æ˜¯è®©æ™ºèƒ½ä½“ä»å†å²äº¤äº’ä¸­ç§¯ç´¯çŸ¥è¯†ï¼Œå¹¶å°†è¿™äº›çŸ¥è¯†åº”ç”¨åˆ°æœªæ¥ä»»åŠ¡ä¸­ã€‚è¿™æ˜¯å®ç°"è¶Šç”¨è¶Šå¥½"çš„å…³é”®èƒ½åŠ›ã€‚

### 4.2 ç»éªŒæ•°æ®æ¨¡å‹

```typescript
// ç»éªŒè®°å½•
interface Experience {
  id: string;
  
  // ä»»åŠ¡ä¿¡æ¯
  taskType: string;           // ä»»åŠ¡ç±»å‹åˆ†ç±»
  taskInput: string;          // åŸå§‹è¾“å…¥
  taskContext: string;        // ä»»åŠ¡ä¸Šä¸‹æ–‡
  
  // æ‰§è¡Œä¿¡æ¯
  approach: string;           // é‡‡ç”¨çš„æ–¹æ³•/ç­–ç•¥
  output: string;             // è¾“å‡ºç»“æœ
  toolsUsed: string[];        // ä½¿ç”¨çš„å·¥å…·
  
  // åé¦ˆä¿¡æ¯
  feedback: ExperienceFeedback;
  
  // æå–çš„çŸ¥è¯†
  lessonsLearned: string[];   // å­¦åˆ°çš„æ•™è®­
  bestPractices: string[];    // æœ€ä½³å®è·µ
  pitfalls: string[];         // éœ€è¦é¿å…çš„å‘
  
  // å…ƒæ•°æ®
  createdAt: Date;
  updatedAt: Date;
}

interface ExperienceFeedback {
  source: 'user' | 'self' | 'system';
  rating: number;             // 1-5 è¯„åˆ†
  outcome: 'success' | 'partial' | 'failure';
  comments: string;
}

// çŸ¥è¯†æ¡ç›®
interface KnowledgeEntry {
  id: string;
  category: 'pattern' | 'rule' | 'heuristic' | 'fact';
  content: string;
  confidence: number;         // ç½®ä¿¡åº¦ 0-1
  supportingExperiences: string[];  // æ”¯æ’‘çš„ç»éªŒ ID
  contradictingExperiences: string[];
  applicableTaskTypes: string[];
  createdAt: Date;
  lastValidated: Date;
}
```

### 4.3 ç»éªŒå­˜å‚¨ä¸æ£€ç´¢

```typescript
import { Chroma } from "@langchain/community/vectorstores/chroma";
import { OpenAIEmbeddings } from "@langchain/openai";
import { Document } from "@langchain/core/documents";

class ExperienceStore {
  private vectorStore: Chroma;
  private embeddings: OpenAIEmbeddings;
  
  constructor() {
    this.embeddings = new OpenAIEmbeddings();
    this.vectorStore = new Chroma(this.embeddings, {
      collectionName: "agent_experiences",
    });
  }
  
  // å­˜å‚¨ç»éªŒ
  async storeExperience(experience: Experience): Promise<void> {
    // å°†ç»éªŒè½¬æ¢ä¸ºå¯åµŒå…¥çš„æ–‡æ¡£
    const doc = new Document({
      pageContent: this.experienceToText(experience),
      metadata: {
        id: experience.id,
        taskType: experience.taskType,
        outcome: experience.feedback.outcome,
        rating: experience.feedback.rating,
        createdAt: experience.createdAt.toISOString(),
      },
    });
    
    await this.vectorStore.addDocuments([doc]);
  }
  
  // æ£€ç´¢ç›¸å…³ç»éªŒ
  async retrieveRelevantExperiences(
    query: string,
    options: {
      k?: number;
      taskType?: string;
      minRating?: number;
      outcomeFilter?: ('success' | 'partial' | 'failure')[];
    } = {}
  ): Promise<Experience[]> {
    const { k = 5, taskType, minRating, outcomeFilter } = options;
    
    // æ„å»ºè¿‡æ»¤æ¡ä»¶
    const filter: Record<string, any> = {};
    if (taskType) filter.taskType = taskType;
    if (minRating) filter.rating = { $gte: minRating };
    if (outcomeFilter) filter.outcome = { $in: outcomeFilter };
    
    const results = await this.vectorStore.similaritySearch(query, k, filter);
    
    return results.map(doc => this.textToExperience(doc.pageContent, doc.metadata));
  }
  
  // è·å–æˆåŠŸç»éªŒ
  async getSuccessExperiences(taskType: string, k: number = 3): Promise<Experience[]> {
    return this.retrieveRelevantExperiences("", {
      k,
      taskType,
      outcomeFilter: ['success'],
      minRating: 4,
    });
  }
  
  // è·å–å¤±è´¥æ•™è®­
  async getFailureLessons(taskType: string, k: number = 3): Promise<Experience[]> {
    return this.retrieveRelevantExperiences("", {
      k,
      taskType,
      outcomeFilter: ['failure'],
    });
  }
  
  private experienceToText(exp: Experience): string {
    return `
      ä»»åŠ¡ç±»å‹: ${exp.taskType}
      ä»»åŠ¡è¾“å…¥: ${exp.taskInput}
      é‡‡ç”¨æ–¹æ³•: ${exp.approach}
      è¾“å‡ºç»“æœ: ${exp.output}
      ç»“æœ: ${exp.feedback.outcome}
      è¯„åˆ†: ${exp.feedback.rating}
      æ•™è®­: ${exp.lessonsLearned.join('; ')}
      æœ€ä½³å®è·µ: ${exp.bestPractices.join('; ')}
      é¿å‘æŒ‡å—: ${exp.pitfalls.join('; ')}
    `;
  }
  
  private textToExperience(text: string, metadata: any): Experience {
    // è§£ææ–‡æœ¬å›ç»éªŒå¯¹è±¡
    // ... å®ç°ç»†èŠ‚ç•¥
    return {} as Experience;
  }
}
```

### 4.4 ç»éªŒå­¦ä¹  Agent

```typescript
import { StateGraph, Annotation } from "@langchain/langgraph";

// å¸¦ç»éªŒå­¦ä¹ çš„çŠ¶æ€
const LearningState = Annotation.Root({
  task: Annotation<string>,
  taskType: Annotation<string>,
  relevantExperiences: Annotation<Experience[]>,
  output: Annotation<string>,
  feedback: Annotation<ExperienceFeedback>,
  newExperience: Annotation<Experience>,
});

const experienceStore = new ExperienceStore();

// ä»»åŠ¡åˆ†ç±»èŠ‚ç‚¹
async function classifyTask(state: typeof LearningState.State) {
  const classification = await llm.invoke(`
    åˆ†æä»¥ä¸‹ä»»åŠ¡ï¼Œè¿”å›ä»»åŠ¡ç±»å‹æ ‡ç­¾:
    
    ä»»åŠ¡: ${state.task}
    
    å¯é€‰ç±»å‹: [ä»£ç ç”Ÿæˆ, æ–‡æ¡£å†™ä½œ, æ•°æ®åˆ†æ, é—®é¢˜è§£ç­”, åˆ›æ„å†™ä½œ, å…¶ä»–]
    
    åªè¿”å›ç±»å‹æ ‡ç­¾ï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚
  `);
  
  return { taskType: classification.content as string };
}

// ç»éªŒæ£€ç´¢èŠ‚ç‚¹
async function retrieveExperiences(state: typeof LearningState.State) {
  // æ£€ç´¢æˆåŠŸç»éªŒ
  const successExperiences = await experienceStore.getSuccessExperiences(
    state.taskType,
    3
  );
  
  // æ£€ç´¢å¤±è´¥æ•™è®­
  const failureLessons = await experienceStore.getFailureLessons(
    state.taskType,
    2
  );
  
  return {
    relevantExperiences: [...successExperiences, ...failureLessons],
  };
}

// å¸¦ç»éªŒæ‰§è¡ŒèŠ‚ç‚¹
async function executeWithExperience(state: typeof LearningState.State) {
  // æ„å»ºç»éªŒä¸Šä¸‹æ–‡
  const experienceContext = state.relevantExperiences.length > 0
    ? `
      ## ç›¸å…³å†å²ç»éªŒ
      
      ### æˆåŠŸæ¡ˆä¾‹å‚è€ƒ
      ${state.relevantExperiences
        .filter(e => e.feedback.outcome === 'success')
        .map(e => `
          - ä»»åŠ¡: ${e.taskInput}
          - æ–¹æ³•: ${e.approach}
          - æœ€ä½³å®è·µ: ${e.bestPractices.join(', ')}
        `).join('\n')}
      
      ### éœ€è¦é¿å…çš„é—®é¢˜
      ${state.relevantExperiences
        .filter(e => e.feedback.outcome === 'failure')
        .map(e => `
          - ä»»åŠ¡: ${e.taskInput}
          - é—®é¢˜: ${e.pitfalls.join(', ')}
          - æ•™è®­: ${e.lessonsLearned.join(', ')}
        `).join('\n')}
    `
    : '';
  
  const response = await llm.invoke(`
    ${experienceContext}
    
    ## å½“å‰ä»»åŠ¡
    ${state.task}
    
    è¯·å‚è€ƒä»¥ä¸Šç»éªŒï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå®Œæˆå½“å‰ä»»åŠ¡ã€‚
    æ³¨æ„é¿å…å†å²ä¸­å‡ºç°è¿‡çš„é—®é¢˜ã€‚
  `);
  
  return { output: response.content as string };
}

// ç»éªŒæå–èŠ‚ç‚¹
async function extractExperience(state: typeof LearningState.State) {
  const extraction = await llm.invoke(`
    åˆ†æè¿™æ¬¡ä»»åŠ¡æ‰§è¡Œï¼Œæå–å¯å¤ç”¨çš„ç»éªŒ:
    
    ## ä»»åŠ¡
    ${state.task}
    
    ## è¾“å‡º
    ${state.output}
    
    ## åé¦ˆ
    ç»“æœ: ${state.feedback.outcome}
    è¯„åˆ†: ${state.feedback.rating}
    è¯„è®º: ${state.feedback.comments}
    
    è¯·æå–:
    1. é‡‡ç”¨çš„æ–¹æ³•/ç­–ç•¥
    2. å­¦åˆ°çš„æ•™è®­ (3-5æ¡)
    3. æœ€ä½³å®è·µ (å¦‚æœæˆåŠŸ)
    4. éœ€è¦é¿å…çš„å‘ (å¦‚æœå¤±è´¥)
    
    ä»¥ JSON æ ¼å¼è¾“å‡º:
    {
      "approach": "...",
      "lessonsLearned": ["...", "..."],
      "bestPractices": ["...", "..."],
      "pitfalls": ["...", "..."]
    }
  `);
  
  const parsed = JSON.parse(extraction.content as string);
  
  const newExperience: Experience = {
    id: `exp_${Date.now()}`,
    taskType: state.taskType,
    taskInput: state.task,
    taskContext: "",
    approach: parsed.approach,
    output: state.output,
    toolsUsed: [],
    feedback: state.feedback,
    lessonsLearned: parsed.lessonsLearned,
    bestPractices: parsed.bestPractices,
    pitfalls: parsed.pitfalls,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  
  // å­˜å‚¨æ–°ç»éªŒ
  await experienceStore.storeExperience(newExperience);
  
  return { newExperience };
}

// æ„å»ºç»éªŒå­¦ä¹ å›¾
const learningGraph = new StateGraph(LearningState)
  .addNode("classify", classifyTask)
  .addNode("retrieve", retrieveExperiences)
  .addNode("execute", executeWithExperience)
  .addNode("extract", extractExperience)
  .addEdge("__start__", "classify")
  .addEdge("classify", "retrieve")
  .addEdge("retrieve", "execute")
  .addEdge("execute", "extract")
  .addEdge("extract", "__end__")
  .compile();
```

### 4.5 çŸ¥è¯†è’¸é¦

ä»å¤§é‡ç»éªŒä¸­æç‚¼é€šç”¨çŸ¥è¯†è§„åˆ™ï¼š

```typescript
class KnowledgeDistiller {
  private experienceStore: ExperienceStore;
  private knowledgeStore: KnowledgeStore;
  
  // å®šæœŸè’¸é¦çŸ¥è¯†
  async distillKnowledge(taskType: string): Promise<KnowledgeEntry[]> {
    // è·å–è¯¥ç±»å‹çš„æ‰€æœ‰ç»éªŒ
    const experiences = await this.experienceStore.getAllByTaskType(taskType);
    
    if (experiences.length < 10) {
      console.log("ç»éªŒä¸è¶³ï¼Œæš‚ä¸è¿›è¡ŒçŸ¥è¯†è’¸é¦");
      return [];
    }
    
    // åˆ†ææˆåŠŸæ¨¡å¼
    const successPatterns = await this.analyzeSuccessPatterns(
      experiences.filter(e => e.feedback.outcome === 'success')
    );
    
    // åˆ†æå¤±è´¥æ¨¡å¼
    const failurePatterns = await this.analyzeFailurePatterns(
      experiences.filter(e => e.feedback.outcome === 'failure')
    );
    
    // æå–é€šç”¨è§„åˆ™
    const rules = await this.extractRules(successPatterns, failurePatterns);
    
    // å­˜å‚¨çŸ¥è¯†
    for (const rule of rules) {
      await this.knowledgeStore.store(rule);
    }
    
    return rules;
  }
  
  private async analyzeSuccessPatterns(experiences: Experience[]): Promise<string[]> {
    const analysis = await llm.invoke(`
      åˆ†æä»¥ä¸‹æˆåŠŸæ¡ˆä¾‹ï¼Œæ‰¾å‡ºå…±åŒçš„æˆåŠŸæ¨¡å¼:
      
      ${experiences.map(e => `
        - ä»»åŠ¡: ${e.taskInput}
        - æ–¹æ³•: ${e.approach}
        - æœ€ä½³å®è·µ: ${e.bestPractices.join(', ')}
      `).join('\n')}
      
      è¯·æ€»ç»“ 3-5 æ¡é€šç”¨çš„æˆåŠŸæ¨¡å¼ã€‚
    `);
    
    return (analysis.content as string).split('\n').filter(s => s.trim());
  }
  
  private async analyzeFailurePatterns(experiences: Experience[]): Promise<string[]> {
    const analysis = await llm.invoke(`
      åˆ†æä»¥ä¸‹å¤±è´¥æ¡ˆä¾‹ï¼Œæ‰¾å‡ºå…±åŒçš„å¤±è´¥åŸå› :
      
      ${experiences.map(e => `
        - ä»»åŠ¡: ${e.taskInput}
        - é—®é¢˜: ${e.pitfalls.join(', ')}
        - æ•™è®­: ${e.lessonsLearned.join(', ')}
      `).join('\n')}
      
      è¯·æ€»ç»“ 3-5 æ¡éœ€è¦é¿å…çš„å…±åŒé—®é¢˜ã€‚
    `);
    
    return (analysis.content as string).split('\n').filter(s => s.trim());
  }
  
  private async extractRules(
    successPatterns: string[],
    failurePatterns: string[]
  ): Promise<KnowledgeEntry[]> {
    const rulesPrompt = `
      åŸºäºä»¥ä¸‹åˆ†æï¼Œç”Ÿæˆå¯æ‰§è¡Œçš„è§„åˆ™:
      
      ## æˆåŠŸæ¨¡å¼
      ${successPatterns.join('\n')}
      
      ## å¤±è´¥æ¨¡å¼
      ${failurePatterns.join('\n')}
      
      ç”Ÿæˆ JSON æ ¼å¼çš„è§„åˆ™åˆ—è¡¨:
      [
        {
          "category": "rule",
          "content": "è§„åˆ™å†…å®¹",
          "confidence": 0.8,
          "applicableTaskTypes": ["ä»»åŠ¡ç±»å‹"]
        }
      ]
    `;
    
    const response = await llm.invoke(rulesPrompt);
    return JSON.parse(response.content as string);
  }
}
```

---

## äº”ã€Level 3: ç­–ç•¥è‡ªä¼˜åŒ– (Strategy Optimization)

### 5.1 æ¦‚è¿°

ç­–ç•¥è‡ªä¼˜åŒ–æ˜¯è®©æ™ºèƒ½ä½“èƒ½å¤Ÿè‡ªåŠ¨æ”¹è¿›å…¶å†³ç­–ç­–ç•¥ï¼ŒåŒ…æ‹¬ Prompt ä¼˜åŒ–ã€å·¥å…·é€‰æ‹©ç­–ç•¥ã€ä»»åŠ¡åˆ†è§£ç­–ç•¥ç­‰ã€‚

âš ï¸ **é£é™©è­¦å‘Š**ï¼šè‡ªåŠ¨ä¼˜åŒ–æœ‰å¤±æ§é£é™©ï¼Œéœ€è¦ä¸¥æ ¼çš„éªŒè¯å’Œå›æ»šæœºåˆ¶ã€‚

### 5.2 Prompt è‡ªä¼˜åŒ–ç³»ç»Ÿ

```typescript
interface PromptVersion {
  id: string;
  version: number;
  prompt: string;
  
  // æ€§èƒ½æŒ‡æ ‡
  metrics: {
    successRate: number;
    averageRating: number;
    sampleSize: number;
  };
  
  // å˜æ›´è®°å½•
  changelog: string;
  parentVersion: string | null;
  
  // çŠ¶æ€
  status: 'draft' | 'testing' | 'active' | 'deprecated';
  
  createdAt: Date;
}

class PromptEvolutionService {
  private promptHistory: Map<string, PromptVersion[]> = new Map();
  private activePrompts: Map<string, PromptVersion> = new Map();
  
  // åŸºäºåé¦ˆç”Ÿæˆä¼˜åŒ–å»ºè®®
  async analyzeAndSuggestOptimization(
    promptId: string,
    recentResults: { input: string; output: string; rating: number }[]
  ): Promise<string | null> {
    const currentPrompt = this.activePrompts.get(promptId);
    if (!currentPrompt) return null;
    
    const successCases = recentResults.filter(r => r.rating >= 4);
    const failureCases = recentResults.filter(r => r.rating <= 2);
    
    // æ ·æœ¬ä¸è¶³
    if (recentResults.length < 20) {
      return null;
    }
    
    // æ€§èƒ½å·²ç»å¾ˆå¥½
    const successRate = successCases.length / recentResults.length;
    if (successRate >= 0.9) {
      return null;
    }
    
    // åˆ†æå¤±è´¥åŸå› 
    const analysis = await llm.invoke(`
      ä½ æ˜¯ Prompt å·¥ç¨‹ä¸“å®¶ã€‚åˆ†æä»¥ä¸‹ Prompt çš„è¡¨ç°å¹¶æå‡ºæ”¹è¿›å»ºè®®ã€‚
      
      ## å½“å‰ Prompt
      ${currentPrompt.prompt}
      
      ## æˆåŠŸæ¡ˆä¾‹ (${successCases.length}/${recentResults.length})
      ${successCases.slice(0, 3).map(c => `
        è¾“å…¥: ${c.input.slice(0, 100)}...
        è¯„åˆ†: ${c.rating}
      `).join('\n')}
      
      ## å¤±è´¥æ¡ˆä¾‹ (${failureCases.length}/${recentResults.length})
      ${failureCases.slice(0, 5).map(c => `
        è¾“å…¥: ${c.input.slice(0, 100)}...
        è¾“å‡ºæ‘˜è¦: ${c.output.slice(0, 200)}...
        è¯„åˆ†: ${c.rating}
      `).join('\n')}
      
      ## åˆ†æè¦æ±‚
      1. è¯†åˆ«å¤±è´¥æ¡ˆä¾‹çš„å…±åŒé—®é¢˜
      2. åˆ†æ Prompt ä¸­å¯èƒ½å¯¼è‡´é—®é¢˜çš„è¡¨è¿°
      3. æå‡ºå…·ä½“çš„ä¿®æ”¹å»ºè®®
      
      æ³¨æ„ï¼š
      - ä¿æŒ Prompt çš„æ ¸å¿ƒæ„å›¾ä¸å˜
      - ä¿®æ”¹åº”è¯¥æ˜¯æ¸è¿›å¼çš„ï¼Œä¸è¦å¤§å¹…é‡å†™
      - å…³æ³¨æ¸…æ™°åº¦ã€å…·ä½“æ€§å’Œè¾¹ç•Œæ¡ä»¶
    `);
    
    return analysis.content as string;
  }
  
  // ç”Ÿæˆæ–°ç‰ˆæœ¬ Prompt
  async generateOptimizedPrompt(
    promptId: string,
    optimizationSuggestion: string
  ): Promise<PromptVersion> {
    const currentPrompt = this.activePrompts.get(promptId);
    if (!currentPrompt) throw new Error("Prompt not found");
    
    const newPromptResponse = await llm.invoke(`
      æ ¹æ®ä»¥ä¸‹ä¼˜åŒ–å»ºè®®ï¼Œæ”¹è¿› Prompt:
      
      ## å½“å‰ Prompt
      ${currentPrompt.prompt}
      
      ## ä¼˜åŒ–å»ºè®®
      ${optimizationSuggestion}
      
      ## è¦æ±‚
      1. è¾“å‡ºæ”¹è¿›åçš„å®Œæ•´ Prompt
      2. åªåšå¿…è¦çš„ä¿®æ”¹
      3. ä¿æŒåŸæœ‰çš„ç»“æ„å’Œæ ¼å¼
      
      ç›´æ¥è¾“å‡ºæ–°çš„ Promptï¼Œä¸è¦æ·»åŠ è§£é‡Šã€‚
    `);
    
    const newVersion: PromptVersion = {
      id: `${promptId}_v${currentPrompt.version + 1}`,
      version: currentPrompt.version + 1,
      prompt: newPromptResponse.content as string,
      metrics: {
        successRate: 0,
        averageRating: 0,
        sampleSize: 0,
      },
      changelog: optimizationSuggestion,
      parentVersion: currentPrompt.id,
      status: 'draft',
      createdAt: new Date(),
    };
    
    return newVersion;
  }
  
  // A/B æµ‹è¯•æ–° Prompt
  async runABTest(
    promptId: string,
    newVersion: PromptVersion,
    testCases: { input: string; expectedOutput?: string }[],
    minSampleSize: number = 50
  ): Promise<{
    controlMetrics: PromptVersion['metrics'];
    treatmentMetrics: PromptVersion['metrics'];
    recommendation: 'adopt' | 'reject' | 'inconclusive';
  }> {
    const currentPrompt = this.activePrompts.get(promptId)!;
    
    const controlResults: number[] = [];
    const treatmentResults: number[] = [];
    
    for (let i = 0; i < testCases.length; i++) {
      const testCase = testCases[i];
      
      // éšæœºåˆ†é…åˆ°å¯¹ç…§ç»„æˆ–å®éªŒç»„
      const isControl = Math.random() > 0.5;
      const prompt = isControl ? currentPrompt.prompt : newVersion.prompt;
      
      // æ‰§è¡Œå¹¶è¯„ä¼°
      const result = await this.executeAndEvaluate(prompt, testCase);
      
      if (isControl) {
        controlResults.push(result.rating);
      } else {
        treatmentResults.push(result.rating);
      }
    }
    
    // è®¡ç®—æŒ‡æ ‡
    const controlMetrics = this.calculateMetrics(controlResults);
    const treatmentMetrics = this.calculateMetrics(treatmentResults);
    
    // ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ
    const recommendation = this.makeRecommendation(
      controlMetrics,
      treatmentMetrics,
      minSampleSize
    );
    
    return { controlMetrics, treatmentMetrics, recommendation };
  }
  
  // é‡‡ç”¨æ–°ç‰ˆæœ¬
  async adoptNewVersion(promptId: string, newVersion: PromptVersion): Promise<void> {
    const currentPrompt = this.activePrompts.get(promptId);
    if (currentPrompt) {
      currentPrompt.status = 'deprecated';
    }
    
    newVersion.status = 'active';
    this.activePrompts.set(promptId, newVersion);
    
    // è®°å½•å†å²
    const history = this.promptHistory.get(promptId) || [];
    history.push(newVersion);
    this.promptHistory.set(promptId, history);
    
    console.log(`Prompt ${promptId} å·²æ›´æ–°åˆ°ç‰ˆæœ¬ ${newVersion.version}`);
  }
  
  // å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬
  async rollback(promptId: string): Promise<void> {
    const history = this.promptHistory.get(promptId);
    if (!history || history.length < 2) {
      throw new Error("æ— æ³•å›æ»šï¼šå†å²ç‰ˆæœ¬ä¸è¶³");
    }
    
    const currentVersion = this.activePrompts.get(promptId)!;
    currentVersion.status = 'deprecated';
    
    const previousVersion = history[history.length - 2];
    previousVersion.status = 'active';
    this.activePrompts.set(promptId, previousVersion);
    
    console.log(`Prompt ${promptId} å·²å›æ»šåˆ°ç‰ˆæœ¬ ${previousVersion.version}`);
  }
  
  private calculateMetrics(ratings: number[]): PromptVersion['metrics'] {
    const successCount = ratings.filter(r => r >= 4).length;
    return {
      successRate: successCount / ratings.length,
      averageRating: ratings.reduce((a, b) => a + b, 0) / ratings.length,
      sampleSize: ratings.length,
    };
  }
  
  private makeRecommendation(
    control: PromptVersion['metrics'],
    treatment: PromptVersion['metrics'],
    minSampleSize: number
  ): 'adopt' | 'reject' | 'inconclusive' {
    // æ ·æœ¬ä¸è¶³
    if (control.sampleSize < minSampleSize || treatment.sampleSize < minSampleSize) {
      return 'inconclusive';
    }
    
    // æ˜¾è‘—æå‡ï¼ˆæˆåŠŸç‡æå‡ > 5%ï¼‰
    if (treatment.successRate > control.successRate + 0.05) {
      return 'adopt';
    }
    
    // æ˜¾è‘—ä¸‹é™
    if (treatment.successRate < control.successRate - 0.05) {
      return 'reject';
    }
    
    return 'inconclusive';
  }
  
  private async executeAndEvaluate(
    prompt: string,
    testCase: { input: string; expectedOutput?: string }
  ): Promise<{ output: string; rating: number }> {
    // æ‰§è¡Œ
    const response = await llm.invoke(`${prompt}\n\n${testCase.input}`);
    const output = response.content as string;
    
    // è¯„ä¼°
    const evalResponse = await llm.invoke(`
      è¯„ä¼°ä»¥ä¸‹è¾“å‡ºçš„è´¨é‡ (1-5åˆ†):
      
      è¾“å…¥: ${testCase.input}
      ${testCase.expectedOutput ? `æœŸæœ›è¾“å‡º: ${testCase.expectedOutput}` : ''}
      å®é™…è¾“å‡º: ${output}
      
      åªè¿”å›æ•°å­—è¯„åˆ†ã€‚
    `);
    
    const rating = parseInt(evalResponse.content as string) || 3;
    
    return { output, rating };
  }
}
```

### 5.3 å·¥å…·é€‰æ‹©ç­–ç•¥ä¼˜åŒ–

```typescript
interface ToolUsageStats {
  toolName: string;
  totalCalls: number;
  successfulCalls: number;
  averageLatency: number;
  commonErrors: string[];
  bestUseCases: string[];
  worstUseCases: string[];
}

class ToolSelectionOptimizer {
  private toolStats: Map<string, ToolUsageStats> = new Map();
  
  // è®°å½•å·¥å…·ä½¿ç”¨
  async recordToolUsage(
    toolName: string,
    input: any,
    output: any,
    success: boolean,
    latency: number,
    context: string
  ): Promise<void> {
    const stats = this.toolStats.get(toolName) || this.initStats(toolName);
    
    stats.totalCalls++;
    if (success) stats.successfulCalls++;
    stats.averageLatency = 
      (stats.averageLatency * (stats.totalCalls - 1) + latency) / stats.totalCalls;
    
    // æ›´æ–°ä½¿ç”¨åœºæ™¯
    if (success) {
      stats.bestUseCases.push(context);
    } else {
      stats.worstUseCases.push(context);
    }
    
    this.toolStats.set(toolName, stats);
  }
  
  // ç”Ÿæˆå·¥å…·é€‰æ‹©å»ºè®®
  async generateToolSelectionGuide(): Promise<string> {
    const allStats = Array.from(this.toolStats.values());
    
    const guide = await llm.invoke(`
      åŸºäºä»¥ä¸‹å·¥å…·ä½¿ç”¨ç»Ÿè®¡ï¼Œç”Ÿæˆå·¥å…·é€‰æ‹©æŒ‡å—:
      
      ${allStats.map(s => `
        ## ${s.toolName}
        - æˆåŠŸç‡: ${(s.successfulCalls / s.totalCalls * 100).toFixed(1)}%
        - å¹³å‡å»¶è¿Ÿ: ${s.averageLatency.toFixed(0)}ms
        - æœ€ä½³åœºæ™¯: ${s.bestUseCases.slice(-5).join(', ')}
        - ä¸é€‚åˆåœºæ™¯: ${s.worstUseCases.slice(-5).join(', ')}
      `).join('\n')}
      
      ç”Ÿæˆä¸€ä»½ç®€æ´çš„å·¥å…·é€‰æ‹©å†³ç­–æ ‘ï¼Œå¸®åŠ©å†³å®šä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨ä»€ä¹ˆå·¥å…·ã€‚
    `);
    
    return guide.content as string;
  }
  
  // æ¨èå·¥å…·
  async recommendTool(taskDescription: string, availableTools: string[]): Promise<string> {
    const relevantStats = availableTools
      .map(t => this.toolStats.get(t))
      .filter(Boolean) as ToolUsageStats[];
    
    const recommendation = await llm.invoke(`
      æ ¹æ®ä»»åŠ¡æè¿°å’Œå·¥å…·ç»Ÿè®¡ï¼Œæ¨èæœ€åˆé€‚çš„å·¥å…·:
      
      ## ä»»åŠ¡
      ${taskDescription}
      
      ## å¯ç”¨å·¥å…·ç»Ÿè®¡
      ${relevantStats.map(s => `
        - ${s.toolName}: æˆåŠŸç‡ ${(s.successfulCalls / s.totalCalls * 100).toFixed(1)}%
          æœ€ä½³åœºæ™¯: ${s.bestUseCases.slice(-3).join(', ')}
      `).join('\n')}
      
      è¿”å›æ¨èçš„å·¥å…·åç§°å’Œç†ç”±ã€‚
    `);
    
    return recommendation.content as string;
  }
  
  private initStats(toolName: string): ToolUsageStats {
    return {
      toolName,
      totalCalls: 0,
      successfulCalls: 0,
      averageLatency: 0,
      commonErrors: [],
      bestUseCases: [],
      worstUseCases: [],
    };
  }
}
```

---

## å…­ã€LangGraph é•¿æœŸè®°å¿†é›†æˆ

### 6.1 ä½¿ç”¨ MemoryStore æŒä¹…åŒ–å­¦ä¹ æ•°æ®

```typescript
import { InMemoryStore, PostgresStore } from "@langchain/langgraph";

// ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ PostgresStore
const memoryStore = process.env.NODE_ENV === 'production'
  ? new PostgresStore({ connectionString: process.env.DATABASE_URL })
  : new InMemoryStore();

// å‘½åç©ºé—´å®šä¹‰
const NAMESPACES = {
  EXPERIENCES: ["learning", "experiences"],
  KNOWLEDGE: ["learning", "knowledge"],
  PROMPTS: ["learning", "prompts"],
  TOOL_STATS: ["learning", "tools"],
  USER_FEEDBACK: ["learning", "feedback"],
};

// ç»éªŒå­˜å‚¨é€‚é…å™¨
class LangGraphExperienceAdapter {
  
  async saveExperience(userId: string, experience: Experience): Promise<void> {
    await memoryStore.put(
      [...NAMESPACES.EXPERIENCES, userId],
      experience.id,
      {
        value: experience,
        createdAt: experience.createdAt.toISOString(),
      }
    );
  }
  
  async getExperiences(userId: string, limit: number = 50): Promise<Experience[]> {
    const results = await memoryStore.search(
      [...NAMESPACES.EXPERIENCES, userId],
      { limit }
    );
    
    return results.map(r => r.value.value as Experience);
  }
  
  async saveKnowledge(entry: KnowledgeEntry): Promise<void> {
    await memoryStore.put(
      NAMESPACES.KNOWLEDGE,
      entry.id,
      {
        value: entry,
        category: entry.category,
        confidence: entry.confidence,
      }
    );
  }
  
  async getKnowledge(category?: string): Promise<KnowledgeEntry[]> {
    const results = await memoryStore.search(NAMESPACES.KNOWLEDGE, {
      filter: category ? { category } : undefined,
    });
    
    return results.map(r => r.value.value as KnowledgeEntry);
  }
}
```

### 6.2 å®Œæ•´çš„è‡ªè¿›åŒ– Agent

```typescript
import { StateGraph, Annotation, MemorySaver } from "@langchain/langgraph";

// å®Œæ•´çŠ¶æ€å®šä¹‰
const SelfEvolvingState = Annotation.Root({
  // è¾“å…¥
  task: Annotation<string>,
  userId: Annotation<string>,
  
  // ä¸Šä¸‹æ–‡
  taskType: Annotation<string>,
  relevantExperiences: Annotation<Experience[]>,
  relevantKnowledge: Annotation<KnowledgeEntry[]>,
  
  // æ‰§è¡Œ
  plan: Annotation<string>,
  output: Annotation<string>,
  
  // åæ€
  selfCritique: Annotation<string>,
  qualityScore: Annotation<number>,
  iterationCount: Annotation<number>,
  
  // å­¦ä¹ 
  feedback: Annotation<ExperienceFeedback>,
  newExperience: Annotation<Experience>,
  
  // æ§åˆ¶
  status: Annotation<'planning' | 'executing' | 'reflecting' | 'learning' | 'done'>,
});

// æ„å»ºè‡ªè¿›åŒ– Agent
function buildSelfEvolvingAgent() {
  const experienceAdapter = new LangGraphExperienceAdapter();
  
  // è§„åˆ’èŠ‚ç‚¹
  async function plan(state: typeof SelfEvolvingState.State) {
    // åˆ†ç±»ä»»åŠ¡
    const taskType = await classifyTask(state.task);
    
    // æ£€ç´¢ç›¸å…³ç»éªŒ
    const experiences = await experienceAdapter.getExperiences(state.userId);
    const relevantExperiences = experiences
      .filter(e => e.taskType === taskType)
      .slice(0, 5);
    
    // æ£€ç´¢ç›¸å…³çŸ¥è¯†
    const knowledge = await experienceAdapter.getKnowledge();
    const relevantKnowledge = knowledge
      .filter(k => k.applicableTaskTypes.includes(taskType));
    
    // ç”Ÿæˆè®¡åˆ’
    const planPrompt = `
      ## ä»»åŠ¡
      ${state.task}
      
      ## ç›¸å…³ç»éªŒ
      ${relevantExperiences.map(e => `
        - ${e.taskInput}: ${e.feedback.outcome} (${e.lessonsLearned.join(', ')})
      `).join('\n')}
      
      ## ç›¸å…³çŸ¥è¯†
      ${relevantKnowledge.map(k => `- ${k.content}`).join('\n')}
      
      è¯·åˆ¶å®šæ‰§è¡Œè®¡åˆ’ã€‚
    `;
    
    const planResponse = await llm.invoke(planPrompt);
    
    return {
      taskType,
      relevantExperiences,
      relevantKnowledge,
      plan: planResponse.content as string,
      status: 'executing' as const,
    };
  }
  
  // æ‰§è¡ŒèŠ‚ç‚¹
  async function execute(state: typeof SelfEvolvingState.State) {
    const executePrompt = `
      ## ä»»åŠ¡
      ${state.task}
      
      ## æ‰§è¡Œè®¡åˆ’
      ${state.plan}
      
      ## æ³¨æ„äº‹é¡¹ï¼ˆåŸºäºå†å²ç»éªŒï¼‰
      ${state.relevantExperiences
        .filter(e => e.feedback.outcome === 'failure')
        .flatMap(e => e.pitfalls)
        .join('\n- ')}
      
      è¯·æ‰§è¡Œä»»åŠ¡ã€‚
    `;
    
    const response = await llm.invoke(executePrompt);
    
    return {
      output: response.content as string,
      status: 'reflecting' as const,
    };
  }
  
  // åæ€èŠ‚ç‚¹
  async function reflect(state: typeof SelfEvolvingState.State) {
    const reflectPrompt = `
      è¯„ä¼°ä»¥ä¸‹è¾“å‡ºçš„è´¨é‡:
      
      ## ä»»åŠ¡
      ${state.task}
      
      ## è¾“å‡º
      ${state.output}
      
      ## è¯„ä¼°ç»´åº¦
      1. å‡†ç¡®æ€§ (0-10)
      2. å®Œæ•´æ€§ (0-10)
      3. æ¸…æ™°åº¦ (0-10)
      
      è¿”å› JSON:
      {
        "scores": { "accuracy": X, "completeness": X, "clarity": X },
        "overall": X,
        "critique": "æ”¹è¿›å»ºè®®æˆ– APPROVED"
      }
    `;
    
    const response = await llm.invoke(reflectPrompt);
    const evaluation = JSON.parse(response.content as string);
    
    const needsIteration = 
      evaluation.overall < 7 && 
      state.iterationCount < 3 &&
      evaluation.critique !== "APPROVED";
    
    return {
      selfCritique: evaluation.critique,
      qualityScore: evaluation.overall,
      iterationCount: state.iterationCount + 1,
      status: needsIteration ? 'executing' as const : 'learning' as const,
    };
  }
  
  // å­¦ä¹ èŠ‚ç‚¹
  async function learn(state: typeof SelfEvolvingState.State) {
    // æå–ç»éªŒ
    const extractPrompt = `
      æå–è¿™æ¬¡ä»»åŠ¡çš„ç»éªŒ:
      
      ä»»åŠ¡: ${state.task}
      è¾“å‡º: ${state.output}
      è´¨é‡è¯„åˆ†: ${state.qualityScore}
      
      è¿”å› JSON:
      {
        "approach": "é‡‡ç”¨çš„æ–¹æ³•",
        "lessonsLearned": ["æ•™è®­1", "æ•™è®­2"],
        "bestPractices": ["æœ€ä½³å®è·µ1"],
        "pitfalls": ["éœ€è¦é¿å…çš„é—®é¢˜"]
      }
    `;
    
    const response = await llm.invoke(extractPrompt);
    const extracted = JSON.parse(response.content as string);
    
    const newExperience: Experience = {
      id: `exp_${Date.now()}`,
      taskType: state.taskType,
      taskInput: state.task,
      taskContext: "",
      approach: extracted.approach,
      output: state.output,
      toolsUsed: [],
      feedback: state.feedback || {
        source: 'self',
        rating: Math.round(state.qualityScore / 2),
        outcome: state.qualityScore >= 7 ? 'success' : 'partial',
        comments: state.selfCritique,
      },
      lessonsLearned: extracted.lessonsLearned,
      bestPractices: extracted.bestPractices,
      pitfalls: extracted.pitfalls,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    
    // ä¿å­˜ç»éªŒ
    await experienceAdapter.saveExperience(state.userId, newExperience);
    
    return {
      newExperience,
      status: 'done' as const,
    };
  }
  
  // è·¯ç”±å‡½æ•°
  function route(state: typeof SelfEvolvingState.State): string {
    switch (state.status) {
      case 'planning': return 'plan';
      case 'executing': return 'execute';
      case 'reflecting': return 'reflect';
      case 'learning': return 'learn';
      case 'done': return '__end__';
      default: return 'plan';
    }
  }
  
  // æ„å»ºå›¾
  const graph = new StateGraph(SelfEvolvingState)
    .addNode("plan", plan)
    .addNode("execute", execute)
    .addNode("reflect", reflect)
    .addNode("learn", learn)
    .addConditionalEdges("__start__", route)
    .addConditionalEdges("plan", route)
    .addConditionalEdges("execute", route)
    .addConditionalEdges("reflect", route)
    .addConditionalEdges("learn", route)
    .compile({
      checkpointer: new MemorySaver(),  // æ”¯æŒæ–­ç‚¹æ¢å¤
    });
  
  return graph;
}
```

---

## ä¸ƒã€å®ç°è·¯çº¿å›¾

### 7.1 é˜¶æ®µè§„åˆ’

| é˜¶æ®µ | ç›®æ ‡ | åŠŸèƒ½ | æ—¶é—´ |
|-----|------|------|------|
| **P0 MVP** | åŸºç¡€åæ€ | ç”Ÿæˆ-è¯„ä¼°-æ”¹è¿›å¾ªç¯ | 1-2 å‘¨ |
| **P1** | ç»éªŒå­¦ä¹  | ç»éªŒå­˜å‚¨ã€æ£€ç´¢ã€åº”ç”¨ | 2-3 å‘¨ |
| **P2** | çŸ¥è¯†è’¸é¦ | ä»ç»éªŒä¸­æå–é€šç”¨è§„åˆ™ | 2 å‘¨ |
| **P3** | ç­–ç•¥ä¼˜åŒ– | Prompt A/B æµ‹è¯•ã€è‡ªåŠ¨ä¼˜åŒ– | 3-4 å‘¨ |
| **P4** | å®Œæ•´ç³»ç»Ÿ | å„æ¨¡å—é›†æˆã€ç”Ÿäº§åŒ– | 2-3 å‘¨ |

### 7.2 å„é˜¶æ®µè¯¦ç»†ä»»åŠ¡

#### P0 MVP ä»»åŠ¡æ¸…å•
- [ ] å®ç°åŸºç¡€çš„ Reflection å›¾ç»“æ„
- [ ] å®ç°å¤šç»´åº¦è¯„ä¼°ï¼ˆå‡†ç¡®æ€§ã€å®Œæ•´æ€§ã€æ¸…æ™°åº¦ï¼‰
- [ ] å®ç°è¿­ä»£æ”¹è¿›å¾ªç¯
- [ ] æ·»åŠ æœ€å¤§è¿­ä»£æ¬¡æ•°é™åˆ¶

#### P1 ç»éªŒå­¦ä¹ ä»»åŠ¡æ¸…å•
- [ ] è®¾è®¡ç»éªŒæ•°æ®æ¨¡å‹
- [ ] é›†æˆå‘é‡æ•°æ®åº“ï¼ˆChromaï¼‰
- [ ] å®ç°ç»éªŒå­˜å‚¨å’Œæ£€ç´¢
- [ ] å®ç°ä»»åŠ¡åˆ†ç±»
- [ ] å°†ç»éªŒæ³¨å…¥åˆ°æ‰§è¡Œ Prompt

#### P2 çŸ¥è¯†è’¸é¦ä»»åŠ¡æ¸…å•
- [ ] å®ç°æˆåŠŸ/å¤±è´¥æ¨¡å¼åˆ†æ
- [ ] å®ç°è§„åˆ™æå–
- [ ] å®ç°çŸ¥è¯†ç½®ä¿¡åº¦è®¡ç®—
- [ ] å®šæœŸçŸ¥è¯†è’¸é¦ä»»åŠ¡

#### P3 ç­–ç•¥ä¼˜åŒ–ä»»åŠ¡æ¸…å•
- [ ] å®ç° Prompt ç‰ˆæœ¬ç®¡ç†
- [ ] å®ç° A/B æµ‹è¯•æ¡†æ¶
- [ ] å®ç°è‡ªåŠ¨ä¼˜åŒ–å»ºè®®ç”Ÿæˆ
- [ ] å®ç°å®‰å…¨çš„ç‰ˆæœ¬åˆ‡æ¢å’Œå›æ»š

---

## å…«ã€æ³¨æ„äº‹é¡¹

### 8.1 æŠ€æœ¯é™åˆ¶

| é™åˆ¶ | è¯´æ˜ | åº”å¯¹ç­–ç•¥ |
|-----|------|---------|
| **æ— æ³•ä¿®æ”¹è‡ªèº«æƒé‡** | LLM æ— æ³•çœŸæ­£"å­¦ä¹ " | é€šè¿‡å¤–éƒ¨å­˜å‚¨æ¨¡æ‹Ÿå­¦ä¹  |
| **ä¸Šä¸‹æ–‡çª—å£æœ‰é™** | æ— æ³•ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰ç»éªŒ | RAG æ£€ç´¢ç›¸å…³ç»éªŒ |
| **è‡ªä¼˜åŒ–é£é™©** | å¯èƒ½ä¼˜åŒ–åˆ°é”™è¯¯æ–¹å‘ | ä¸¥æ ¼çš„ A/B æµ‹è¯•å’Œå›æ»š |
| **åé¦ˆä¾èµ–** | éœ€è¦æ˜ç¡®çš„åé¦ˆä¿¡å· | å¤šç§åé¦ˆæ¥æºï¼ˆç”¨æˆ·/è‡ªè¯„/ç³»ç»Ÿï¼‰ |

### 8.2 å®‰å…¨è€ƒè™‘

```typescript
// ç­–ç•¥æ›´æ–°çš„å®‰å…¨æ£€æŸ¥
interface SafetyCheck {
  // æœ€å°æ ·æœ¬é‡
  minSampleSize: number;
  
  // æœ€å°æå‡é˜ˆå€¼
  minImprovement: number;
  
  // å›æ»šè§¦å‘æ¡ä»¶
  rollbackThreshold: number;
  
  // äººå·¥å®¡æ ¸è¦æ±‚
  requireHumanReview: boolean;
}

const DEFAULT_SAFETY_CONFIG: SafetyCheck = {
  minSampleSize: 50,
  minImprovement: 0.05,  // è‡³å°‘ 5% æå‡
  rollbackThreshold: 0.1, // ä¸‹é™è¶…è¿‡ 10% è‡ªåŠ¨å›æ»š
  requireHumanReview: true,
};
```

### 8.3 ç›‘æ§æŒ‡æ ‡

```typescript
interface EvolutionMetrics {
  // å­¦ä¹ æ•ˆæœ
  experienceCount: number;
  knowledgeCount: number;
  averageTaskSuccessRate: number;
  successRateTrend: number[];  // éšæ—¶é—´çš„å˜åŒ–
  
  // åæ€æ•ˆæœ
  averageIterationsPerTask: number;
  firstAttemptSuccessRate: number;
  
  // ä¼˜åŒ–æ•ˆæœ
  promptVersions: number;
  activePromptSuccessRate: number;
  
  // ç³»ç»Ÿå¥åº·
  averageLatency: number;
  errorRate: number;
}
```

---

## ä¹ã€å‚è€ƒèµ„æº

- [LangGraph æ–‡æ¡£](https://langchain-ai.github.io/langgraph/)
- [LangChain Memory](https://python.langchain.com/docs/modules/memory/)
- [Reflexion: Language Agents with Verbal Reinforcement Learning](https://arxiv.org/abs/2303.11366)
- [Self-Refine: Iterative Refinement with Self-Feedback](https://arxiv.org/abs/2303.17651)
- [Constitutional AI: Harmlessness from AI Feedback](https://arxiv.org/abs/2212.08073)
